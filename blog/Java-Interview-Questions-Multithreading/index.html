<!-- This layout is used in all pages. Making changes here will efect all pages. We recommend not to change anything here. --> <!DOCTYPE html><html lang="en"> <!----><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="google-site-verification" content="Cghc1HFx2GBn1D5ans5vLlaX-pme-BY2wJpaLqHs_H0" /><meta name=”keywords” content=”java, openshift, docker, Michal Fabjanski, Fabjanski, github, jekyll, programming, spring, hibernate, spring boot, kubernetes” /><link rel="dns-prefetch" href="//fonts.googleapis.com"><link rel="dns-prefetch" href="//google-analytics.com"><link rel="dns-prefetch" href="//www.google-analytics.com"><link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com"><link rel="dns-prefetch" href="//ajax.googleapis.com"><link rel="dns-prefetch" href="//fonts.gstatic.com"><link rel="dns-prefetch" href="https://dev-diary-2.disqus.com/"><title>Multithreading in Java. Java synchronization and concurrency. The most important information for a Java Developer interview | Devdiaries</title><meta name="generator" content="Jekyll v3.8.4" /><meta property="og:title" content="Multithreading in Java. Java synchronization and concurrency. The most important information for a Java Developer interview" /><meta name="author" content="Michal Fabjanski" /><meta property="og:locale" content="en_US" /><meta name="description" content="Introduction to Java Threads Being a Java programmer, most of us have had any contact with multithreading. One of the biggest challenges is to properly synchronize the code between threads. Fortunately, the language developers have prepared for us a full set of tools that help us achieve this goal. If you are curious or you are preparing for an interview - read this post." /><meta property="og:description" content="Introduction to Java Threads Being a Java programmer, most of us have had any contact with multithreading. One of the biggest challenges is to properly synchronize the code between threads. Fortunately, the language developers have prepared for us a full set of tools that help us achieve this goal. If you are curious or you are preparing for an interview - read this post." /><link rel="canonical" href="https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/" /><meta property="og:url" content="https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/" /><meta property="og:site_name" content="Devdiaries" /><meta property="og:image" content="https://www.devdiaries.net/images/concurrency/concurrency-header-image.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-02-29T00:00:00+00:00" /><script type="application/ld+json"> {"description":"Introduction to Java Threads Being a Java programmer, most of us have had any contact with multithreading. One of the biggest challenges is to properly synchronize the code between threads. Fortunately, the language developers have prepared for us a full set of tools that help us achieve this goal. If you are curious or you are preparing for an interview - read this post.","headline":"Multithreading in Java. Java synchronization and concurrency. The most important information for a Java Developer interview","dateModified":"2020-02-29T00:00:00+00:00","datePublished":"2020-02-29T00:00:00+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/"},"image":"https://www.devdiaries.net/images/concurrency/concurrency-header-image.jpg","url":"https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/","author":{"@type":"Person","name":"Michal Fabjanski"},"@context":"https://schema.org"}</script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"> <!-- Replace these icons with your own. --><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/apple-icon-152x152.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/android-icon-192x192.png"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet"> <!-- Google Analytics code.<head> tag is the right place for analytics code as directed by Google. This is unofficial light version which loads blazing fast! Implemented for faster page load. --><script src="https://cdn.jsdelivr.net/npm/ga-lite@1/dist/ga-lite.min.js" async></script><script> var galite = galite || {}; galite.UA = 'UA-139553005-1';</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.min.js"></script></head><body><div class="loader"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div><div class="wrapper"><div class="container-grid"><div class="sidebar"><div class="author-container shadow"><div class="author"><img src="/images/ja.jpg" width="100%" height="auto;" alt="Devdiaries" onclick="location.href='/'"></div><div class="about text-center"><h1 class="title"><a href="/">Devdiaries</a></h1></div><div class="bio text-center"><p class="m0">Michael`s Blog</p></div><hr class="dashed"><div class="social text-center"> <ul class="portfolio p0"> <li><a href="/about/">About Me</a></li> <li><a href="/categories/">Categories</a></li> <li><a href="/contact/">Contact</a></li> </ul> <ul class="sm p0 m0a"> <li><a href="https://www.linkedin.com/in/michal-fabjanski"><i class="fa fa-linkedin"></i></a></li> <li><a href="https://github.com"><i class="fa fa-github"></i></a></li> </ul></div></div></div><div class="main"><div class="main-container shadow"><div class="title-space"> <h2>Multithreading in Java. Java synchronization and concurrency. The most important information for a Java Developer interview</h2></div><hr class="dashed"> <main> <ul class="breadcrumbs"> <li><a href="/">Home</a></li> <li><a href="/blog/">Blog</a></li> <li><a href="#">Java interview qu...</a></li> </ul><div class="meta"> <p> <small> <span> <i class="fa fa-calendar" aria-hidden="true"></i> 29 Feb 2020&nbsp; </span> <span> <i class="fa fa-user" aria-hidden="true"></i> Michal Fabjanski&nbsp; </span> <span> <i class="fa fa-clock-o" aria-hidden="true"></i> 18 mins read. </span> </small> </p></div><div class="featured-image" style="background-image: url(/images/concurrency/concurrency-header-image.jpg)"></div><article> <ul class="toc rev clearfix"> <li><a href="#introduction-to-java-threads">Introduction to Java Threads</a></li> <li><a href="#application-without-multithreading">Application without multithreading</a></li> <li><a href="#application-with-multithreading">Application with multithreading</a> <ul> <li><a href="#what-is-a-java-threads">What is a Java Threads</a></li> <li><a href="#what-is-time-slicing">What is Time Slicing</a></li> <li><a href="#multi-threading-on-multicore-processors">Multi-threading on multicore processors</a></li> <li><a href="#concurrency-vs-parallelism">Concurrency vs Parallelism</a></li> <li><a href="#concurrent-data-processing">Concurrent data processing</a></li> </ul> </li> <li><a href="#java-thread-creation">Java Thread creation</a> <ul> <li><a href="#extending-thread-class">Extending Thread class</a></li> <li><a href="#implementation-of-the-runnable-interface">Implementation of the Runnable interface</a></li> <li><a href="#creating-threads-in-executorservice">Creating threads in ExecutorService</a></li> </ul> </li> <li><a href="#the-java-threads-life-cycle">The Java thread’s life cycle</a></li> <li><a href="#synchronization-in-java">Synchronization in Java</a> <ul> <li><a href="#race-condition">Race Condition</a></li> <li><a href="#java-threads-synchronization">Java Threads Synchronization</a></li> <li><a href="#synchronized-block">Synchronized block</a></li> <li><a href="#synchronized-method">Synchronized method</a></li> <li><a href="#java-thread-in-waiting-state">Java Thread in WAITING state</a></li> <li><a href="#thread-notification">Thread Notification</a></li> <li><a href="#interruption-of-the-thread">Interruption of the thread</a></li> <li><a href="#java-volatile-keyword">Java Volatile keyword</a></li> </ul> </li> <li><a href="#summary">Summary</a></li> </ul> <h1 id="introduction-to-java-threads">Introduction to Java Threads</h1> <p>Being a Java programmer, most of us have had any contact with multithreading. One of the biggest challenges is to properly synchronize the code between threads. Fortunately, the language developers have prepared for us a full set of tools that help us achieve this goal. If you are curious or you are preparing for an interview - read this post.</p> <h1 id="application-without-multithreading">Application without multithreading</h1> <p>Single-threaded programs are simple applications that do not require concurrent execution of tasks. Each of the tasks is run after the previous one is finished. It looks like this: <img src="/images/concurrency/3tasksonecpu.jpg" alt="3threads-on-cpu-devdiaries" /></p> <p>These rectangles represent three tasks to be performed. The length of the rectangles represents the duration of each task. The tasks are started one by one - after the green task ends, the red task begins. You can say that the tasks are executed sequentially.</p> <h1 id="application-with-multithreading">Application with multithreading</h1> <h2 id="what-is-a-java-threads">What is a Java Threads</h2> <p>The threads are a way for the processor to do many things at once. At a given point in time, the processor can only do as many instructions as it has cores (it’s more complicated, but this simplification will allow us to explain more easily). This would mean that you could only have as many programs running at once as you have processor cores - usually two or four on modern computers. To work around this limitation, the processor runs on threads - one program is one (or more) threads.</p> <p>From the developer’s point of view, a thread is a set of instructions that he/she is going to write in the application, and execute in a certain way. An application itself can be composed of several threads and different threads can be executed at the same time.</p> <h2 id="what-is-time-slicing">What is Time Slicing</h2> <p>Going further, does that mean we can only run one thread on a single-core processor? And on a dual-core processor, two threads? Not exactly. This problem was solved by creating a <strong>time-slicing</strong> mechanism. A mechanism that allows one processor core to run multiple threads. However, this <strong>does not happen in parallel</strong>. The image below shows the tasks from the previous point. This time each of them is run in a separate thread, so we have three threads. The mechanism that supervises their work (<strong>Thread Scheduler</strong>) ensures that from time to time the current thread is stopped. Another thread is woken up, gets processor time and is executed by it. This is known as <strong>Context switch</strong>. The sum of the lengths of rectangles in a given color is the same as in the previous example.</p> <p><img src="/images/concurrency/time-slicing.jpg" alt="time-slicing-devdiaries" /></p> <p>It should be remembered that such an approach does not speed up the execution of tasks (it takes time to stop and wake up the threads) - but it does allow to process each “rectangle” a bit. For what purpose? Imagine such tasks:</p> <p><img src="/images/concurrency/long-short-task.jpg" alt="time-slicing-devdiaries" /></p> <p>The green rectangle is a task to open the browser with the last tabs saved (one million tabs). In the meantime, the user presses the night-mode button, which is a very quick task (red rectangle). Unfortunately, it has to wait until the browser is finished opening tabs. Only then will the next task be executed. The same task can be split, and even though each task will take the same amount of time - the user will start the night-mode much faster. He will not have to wait for the browser to open:</p> <p><img src="/images/concurrency/time-slicing-advantage.jpg" alt="time-slicing-devdiaries" /></p> <p>This approach avoids starving the threads. In the above example, without time slicing, the thread with the green task would starve the threads with the blue and red tasks.</p> <h2 id="multi-threading-on-multicore-processors">Multi-threading on multicore processors</h2> <p>Multi-core processors give you the <strong>real ability to run multiple tasks in parallel</strong>. In this case, if each of the tasks is run in a separate thread, the situation looks like in the picture below:</p> <p><img src="/images/concurrency/multicore.jpg" alt="time-slicing-devdiaries" /></p> <p>In your applications, you’ll meet a combination of both approaches. The image below shows an example of how the task is executed on two cores.</p> <p><img src="/images/concurrency/2cores3tasks.jpg" alt="time-slicing-devdiaries" /></p> <h2 id="concurrency-vs-parallelism">Concurrency vs Parallelism</h2> <p>As I mentioned earlier, parallel tasks are only possible on a multi-core CPU. It is important to remember that</p> <blockquote> <p>When there is just one processor, the OS scheduler context switches between different threads to provide <strong>concurrent execution</strong>.</p> </blockquote> <p>and</p> <blockquote> <p>When there are multiple CPUs, each CPU essentially runs an instance of the OS scheduler, thereby executing threads that are waiting to be run. The result is <strong>parallel execution</strong> of the set of threads to be executed.</p> </blockquote> <h2 id="concurrent-data-processing">Concurrent data processing</h2> <p>The threads use the same data (they share the address space). This means that objects available for one thread are also visible in other threads.</p> <p>Variables are available for all threads. Therefore, all threads can modify these variables. This has very serious consequences. I will describe them in more detail later in this post.</p> <h1 id="java-thread-creation">Java Thread creation</h1> <p>Every thread in Java is related to the Thread class. There are several ways to create a thread.</p> <h2 id="extending-thread-class">Extending Thread class</h2> <p>The first way is to create your class, which inherits from Thread class:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java">    
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>  
  <span class="nd">@Override</span>  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Heellooo!"</span><span class="o">);</span>  
  <span class="o">}</span>  
<span class="o">}</span>  
  
<span class="c1">// Creating Thread  </span>
<span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FirstThread</span><span class="o">();</span></code></pre></figure> <p>In this case, you have to override <code class="highlighter-rouge">run()</code> method - it will be executed in a thread. <strong>Extending the Thread class is not good practice.</strong> Note that in Java each class can extend only one class. When you extend the Thread class, after that you can’t extend any other class which you required. Additionally, <code class="highlighter-rouge">extends</code> in Java is used to add/modify some functionality from a subclass. In this case, we do not add/modify anything to Thread class.</p> <h2 id="implementation-of-the-runnable-interface">Implementation of the Runnable interface</h2> <p>The second way is to create a thread using the Thread’s constructor, which accepts the object implementing the <code class="highlighter-rouge">Runnable</code> interface:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java">    
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstThread</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>  
  <span class="nd">@Override</span>  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Heellooo from Runnable :)"</span><span class="o">);</span>  
  <span class="o">}</span>  
<span class="o">}</span>  
  
<span class="c1">// Creating Thread  </span>
<span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">FirstThread</span><span class="o">());</span></code></pre></figure> <p>This time the body of the thread is the implementation of the <code class="highlighter-rouge">run()</code> interface method (the thread will run this method and will work until it is done). Note that you can create a thread using anonymous classes:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java">    
<span class="n">Thread</span> <span class="n">newThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>  
  <span class="nd">@Override</span>  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello from the thread!"</span><span class="o">);</span>  
  <span class="o">}</span>  
<span class="o">});</span></code></pre></figure> <p>Additionally, the Runnable interface is a function interface. Therefore, this can be simplified by using lambda expressions:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"> 
<span class="n">Thread</span> <span class="n">newThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello from the thread!"</span><span class="o">));</span></code></pre></figure> <h2 id="creating-threads-in-executorservice">Creating threads in ExecutorService</h2> <p><code class="highlighter-rouge">ExecutorService</code> is an interface that we do not have to implement on our own, the Java provides us with ready-made implementations. Thanks to that we can easily create a thread or a pool of threads, which will work according to our expectations. The most important methods that this interface provides are:</p> <p><code class="highlighter-rouge">submit(Runnable task)</code> - allows you to send ‘task’ (implementation of the Runnable interface) to be executed (note: <strong>we have no guarantee that it will be started immediately!</strong> It depends on the current status of ExecutorService, task queue, available threads, etc).</p> <p><code class="highlighter-rouge">shutdown()</code> - allows you to finish threads correctly, previously completing all tasks and releasing all resources. Calling this method is required before the application is finished!</p> <p>A detailed explanation of how ExecutorService works and examples will be presented in the next post.</p> <h1 id="the-java-threads-life-cycle">The Java thread’s life cycle</h1> <p>Creating a thread is just the beginning. <strong>Each thread has its life cycle</strong>. Threads can be in one of six states. Permissible states of the thread are in the Thread.State enumeration class:</p> <ul> <li><strong>NEW</strong> - a new thread that has not yet been launched,</li> <li><strong>RUNNABLE</strong> - a thread that can execute its code,</li> <li><strong>TERMINATED</strong> - a thread that has ended,</li> <li><strong>BLOCKED</strong> - thread blocked, waiting for the release of the shared resource,</li> <li><strong>WAITING</strong> - a thread goes to wait state once it calls <code class="highlighter-rouge">wait()</code> on an Object. Once a thread reaches waiting state, <strong>it will need to wait till some other thread calls <code class="highlighter-rouge">notify()</code> or <code class="highlighter-rouge">notifyAll()</code></strong> on the object.</li> <li><strong>TIMED_WAITING</strong> - a thread is waiting for a certain time.</li> </ul> <p><img src="/images/concurrency/threads-states.jpg" alt="thread-states-devdiaries" /></p> <p>The change from the NEW state to the RUNNABLE state is made after calling the <code class="highlighter-rouge">start()</code> method on the thread instance. Only then the thread can be executed. <strong>Each thread can be run exactly once</strong> - the start() method can be called on it only once. Otherwise, the <code class="highlighter-rouge">IllegalThreadStateException</code> exception will be thrown.</p> <h1 id="synchronization-in-java">Synchronization in Java</h1> <h2 id="race-condition">Race Condition</h2> <p>You already know that threads share the address space. I’ve described it in the subsection <a href="https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/#concurrent-data-processing">#concurrent-data-processing</a>. It has very important consequences. See the example below:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>  
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>  
  
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">value</span><span class="o">++;</span>  
  <span class="o">}</span>  
  
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>  
  <span class="o">}</span>  
<span class="o">}</span>  
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RaceCondition</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>  
        <span class="n">Counter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Counter</span><span class="o">();</span>  
  <span class="n">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>  
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>  
                <span class="n">counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>  
  <span class="o">}</span>  
        <span class="o">};</span>  
  
  <span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>  
  <span class="n">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>  
  <span class="n">Thread</span> <span class="n">t3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>  
  
  <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>  
  <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>  
  <span class="n">t3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>  
  
  <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>  
  <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>  
  <span class="n">t3</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>  
  
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">counter</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>  
  <span class="o">}</span>  
<span class="o">}</span></code></pre></figure> <p>As you can see I used a <code class="highlighter-rouge">Thread.joint()</code> method. This method <strong>ensures that the current thread waits for the end of the thread on which the joint was called</strong>. the default main thread waits for the end of the t1 thread, when t1 ends - waits for t2 to end, then it waits for t3 end (the order may be different).</p> <p>There are three threads in the above code, each of them 50 000 times increment the value of the variable by 1, so the finish counter value should be 150 000, right? Try to run this code several times. What results do you get? In my case, the results were returned:</p> <ul> <li>111772</li> <li>102556</li> <li>132565</li> <li>92146</li> </ul> <p>What you’ve seen above is <strong>race condition</strong>. This happens if several threads at the same time modify a variable that is not adapted to such a parallel change. But why did the value attribute have such different values? This is because the <strong>value++ operation (value = value + 1) is not an atomic operation</strong>.</p> <blockquote> <p>An atomic operation is an operation that is indivisible. An atomic operation is performed by a single instruction in the bytecode (in a compiled class).</p> </blockquote> <p>The execution of value++ (value = value + 1) operation consists of several steps:</p> <ol> <li>Get the current value to a temporary variable (not visible in the source code),</li> <li>Add 1 to the temporary variable,</li> <li>Assigning an increased value to value variable.</li> </ol> <p>In the <a href="https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/#what-is-time-slicing">previous subsection, I described time-slicing</a>. It plays a key role here. Imagine a situation in which the T1 thread execute steps 1, 2 and 3 and was context-switching started. Then threads T2 and T3 took step 1. Then thread T2 took steps 2 and 3. After a while, the same happened to thread T3. As a result, threads overwrite outdated values. One of the scenarios is shown in the table below:</p> <table> <thead> <tr> <th>Operation</th> <th>Thread</th> <th>Step</th> <th>Value variable</th> <th>Temp variable value</th> </tr> </thead> <tbody> <tr> <td>1.</td> <td>T1</td> <td>1.</td> <td>0</td> <td>0</td> </tr> <tr> <td>2.</td> <td>T1</td> <td>2.</td> <td>0</td> <td>1</td> </tr> <tr> <td>3.</td> <td>T1</td> <td>3.</td> <td>1</td> <td>1</td> </tr> <tr> <td>4.</td> <td>T2</td> <td>1.</td> <td>1</td> <td>1</td> </tr> <tr> <td>5.</td> <td>T3</td> <td>1.</td> <td>1</td> <td>1</td> </tr> <tr> <td>6.</td> <td>T2</td> <td>2.</td> <td>1</td> <td>2</td> </tr> <tr> <td>7.</td> <td>T2</td> <td>3.</td> <td>2</td> <td>2</td> </tr> <tr> <td>8.</td> <td>T3</td> <td>2.</td> <td>2</td> <td>2</td> </tr> <tr> <td>9.</td> <td>T3</td> <td>3.</td> <td>2</td> <td>2</td> </tr> </tbody> </table> <p>In the example above, operation 9. sets the value to 2 in the T3 thread ignoring the increase in value made by the T2 thread in operation 7. To avoid <em>race condition</em>, it is necessary to <strong>synchronize the threads.</strong></p> <h2 id="java-threads-synchronization">Java Threads Synchronization</h2> <p>In general, thread states are intuitive. The descriptions in the previous section help you understand what happens to a thread in a given state. Well, maybe apart from the <strong>BLOCKED</strong> state. <strong>When is the thread BLOCKED</strong>?</p> <p>A thread that is in the BLOCKED state is waiting for a blocked resource. In Java, blocking is done with <strong>monitors</strong>, which are used to synchronize the threads. Each object in Java is associated with a monitor, which a thread can <em>lock</em> or <em>unlock</em>. <strong>The monitor can only be blocked by one thread at a time</strong>. Thanks to this, objects are used to synchronize threads. For this purpose, the <code class="highlighter-rouge">synchronized</code> keyword is used.</p> <h2 id="synchronized-block">Synchronized block</h2> <p>With a <code class="highlighter-rouge">synchronized</code> block, you can be sure that <strong>everything inside the block is running on up to one thread at a time.</strong> Try to run the modified example from the previous subsection several times:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>  
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>  
  
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>  
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>  
            <span class="n">value</span><span class="o">++;</span>  
  <span class="o">}</span>  
    <span class="o">}</span>  
  
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>  
  <span class="o">}</span>  
<span class="o">}</span></code></pre></figure> <p>Each time the application returns the correct result - 150 000.</p> <h2 id="synchronized-method">Synchronized method</h2> <p>You can also use the <code class="highlighter-rouge">synchronized</code> keyword for the method:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">value</span> <span class="o">++;</span>
<span class="o">}</span></code></pre></figure> <p>In practice, both versions of the increment method are equivalent. Marking the method with the <code class="highlighter-rouge">synchronized </code>keyword is equivalent to placing the whole body of the method in the synchronized block. Which object is used as a monitor depends on the type of method:</p> <ul> <li>standard method - a class (this) instance is used as a monitor.</li> <li>static method - the whole class is used as a monitor</li> </ul> <blockquote> <p>Remember not to abuse synchronized. The code in a synchronized block can only be executed by one thread (it loses the possibility of concurrent execution), which makes the execution of such a program slower. Use synchronized only in places where it is necessary.</p> </blockquote> <h2 id="java-thread-in-waiting-state">Java Thread in WAITING state</h2> <p>One of the ways to put the thread in WAITING state is to call the <code class="highlighter-rouge">Object.wait()</code> method. What the <code class="highlighter-rouge">wait() </code>method does? Imagine a situation where you have two threads. One produces some data, the other consumes it (Producer-Consumer Pattern). <img src="/images/concurrency/producer-consument-pattern.jpg" alt="producer-consument-pattern-devdiaries" /></p> <p>The data-consuming thread (T2) uses a while loop, which is executed until the expected number of items is taken from the queue. The program works. However, it has a subtle problem. Consumer thread works all the time. It takes up CPU time continuously! What’s more, for most of its time, it revolves inside the loop, checking if there are any new messages in the queue. How can this problem be solved? One way may be to put the consumer’s thread to sleep using the Thread.sleep() method. This would also be a waste of time - how do you know how long it will take to produce the next message? For this purpose, it is better to use the <strong>notification mechanism</strong>.</p> <h2 id="thread-notification">Thread Notification</h2> <p>All Java objects, except monitors, contain a special <strong>wait set</strong>. The elements of this set are threads that wait for notification about this object. The only way to modify the content of waiting set is to use methods available in the Object class:</p> <ul> <li><code class="highlighter-rouge">Object.wait()</code> - adding the current thread to the waiting set threads,</li> <li><code class="highlighter-rouge">Object.notify()</code> - notification and waking up one of the pending threads,</li> <li><code class="highlighter-rouge">Object.notifyAll() </code>- to notify and wake up all pending threads.</li> </ul> <p>The producer from the previous section should use the <code class="highlighter-rouge">notify</code> or <code class="highlighter-rouge">notifyAll</code> method to inform consumers of the new message. Consumers should use the <code class="highlighter-rouge">wait</code> method so that they can wait for notifications from the producer.</p> <h2 id="interruption-of-the-thread">Interruption of the thread</h2> <p>Interruption of a thread is indicated by an <code class="highlighter-rouge">InterruptedException</code> exception . A thread can be interrupted when <code class="highlighter-rouge">Thread.interrupt</code> method is called on its instance. When a thread is interrupted, a special flag is set on it, which informs about it (<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Thread.html#interrupted()"><code class="highlighter-rouge">Thread.interrupted</code></a>).</p> <h2 id="java-volatile-keyword">Java Volatile keyword</h2> <p>Java provides another mechanism which is connected to synchronization - <strong>volatile</strong>. The Java specification says that every read of an attribute preceded by this keyword follows its writing. In other words, the <strong>volatile modifier ensures that every thread reading a given attribute will see the latest saved value of that attribute</strong>. However, you have to watch out for modifications that are not atomic - unfortunately, volatile will not protect you. In this case, you will need the synchronization described earlier.</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Volatile --&gt; Guarantees visibility and NOT atomicity
Synchronization (Locking) --&gt; Guarantees visibility and atomicity (if done properly)
</code></pre></div></div><p>You’re probably wondering what this mechanism is for and what the risk is not using volatile. Imagine a multi-threaded application on a single-core processor: <img src="/images/concurrency/Volatile-1core.jpg" alt="Volatile-devdiaries" /></p> <p>The variables are copied from the main memory to CPU cache (due to a much faster access to the CPU cache compared to RAM access time), Now the threads access the memory from the CPU cache rather than computer memory to save time and increase the performance. There’s nothing dangerous here. Let’s go to the 2-core processor:</p> <p><img src="/images/concurrency/Volatile-2core.jpg" alt="Volatile-devdiaries" /></p> <p>In Multi-CPU computer each thread may run in different CPUs, which means, that each thread may copy the variables into the CPU cache of different CPUs. Imagine a situation in which two or more threads have access to a shared object which contains a value variable from the previous point:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>  
<span class="o">}</span></code></pre></figure> <p>Now, T1 and T2 can have different CPU cores. When T1 will make changes to <em>value</em> variable - the changes have occurred in CPU cache and <strong>there is no guarantee that every change in CPU cache will be reflected to the Main Memory immediately</strong>. So when T2 tries to read the updated <code class="highlighter-rouge">value</code> variable value from the main memory, T2 may or may not find the updated value.</p> <p>To protect from this problem, just use the <strong>volatile</strong> keyword.</p> <blockquote> <p>volatile is keyword used with variable to make sure the value are read from and written to main memory rather than CPU cache.</p> </blockquote> <p>This ensures that you get the “really” correct value of the variable.</p> <h1 id="summary">Summary</h1> <p>As you can see, there are many thread synchronization mechanisms available in Java. Please take a look at them to better decide which ones to use when. If you want to know more about concurrency, there will be a post about ExecutorService soon!</p> </article> <hr class="dashed"><div class="row rev"><div class="col-md-12"><div class="share-box"> <i class="fa fa-share-alt" aria-hidden="true"></i> <a class="f nostyle" href="https://www.facebook.com/sharer/sharer.php?u=https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-facebook-official fa"></i></a> <a class="t nostyle" href="https://twitter.com/intent/tweet?text=&url=https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"><i class="fa fa-twitter fa"></i></a> <a class="g nostyle" href="https://plus.google.com/share?url=https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-google-plus fa"></i></a> <a class="r nostyle" href="http://www.reddit.com/submit?url=https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-reddit fa"></i></a> <a class="l nostyle" href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/&title=&summary=&source=dev-diary.github.io" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-linkedin fa"></i></a> <a class="e nostyle" href="mailto:?subject=&amp;body=Check&amp;out&amp;this&amp;site&amp;https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/"><i class="fa fa-envelope fa"></i></a></div></div></div><div class="row"><div class="col-md-12"> <p class="categories rev"> <span><a href="/categories/#java">Java</a></span> <span><a href="/categories/#concurrency">Concurrency</a></span> <span><a href="/categories/#interview">Interview</a></span></p></div></div><div id="disqus_thread"></div><script> var disqus_config = function () { this.page.url = 'https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/'; this.page.identifier = 'https://www.devdiaries.net/blog/Java-Interview-Questions-Multithreading/'; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://dev-diary-2.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> <!--<div class="comment-loader">--> <!--<button class="comments cards">Comments</button>--> <!--</div>--> <!--<div class="disqus hide">Loading comments&hellip;</div>--> <!--<div class="disqus-loading"></div>--> <!--<script>--> <!--/*--> <!-- disqusLoader.js v1.0--> <!-- A JavaScript plugin for lazy-loading Disqus comments widget.--> <!-- - --> <!-- By Osvaldas Valutis, www.osvaldas.info--> <!-- Available for use under the MIT License--> <!--*/--> <!--(function(b,f,l){var r=function(a){a=a.getBoundingClientRect();return{top:a.top+f.body.scrollTop,left:a.left+f.body.scrollLeft}},t=function(a,c){var d=f.createElement("script");d.src=a;d.async=!0;d.setAttribute("data-timestamp",+new Date);d.addEventListener("load",function(){"function"===typeof c&&c()});(f.head||f.body).appendChild(d)};l=function(a,c){var d,e;return function(){var g=this,f=arguments,b=+new Date;d&&b<d+a?(clearTimeout(e),e=setTimeout(function(){d=b;c.apply(g,f)},a)):(d=b,c.apply(g,--> <!--f))}};var m=!1,n=!1,p=!1,k=!1,h="unloaded",e=!1,q=function(){if(!e||!f.body.contains(e)||"loaded"==e.disqusLoaderStatus)return!0;var a=b.pageYOffset,c=r(e).top;if(c-a>b.innerHeight*n||0<a-c-e.offsetHeight-b.innerHeight*n)return!0;(a=f.getElementById("disqus_thread"))&&a.removeAttribute("id");e.setAttribute("id","disqus_thread");e.disqusLoaderStatus="loaded";"loaded"==h?DISQUS.reset({reload:!0,config:p}):(b.disqus_config=p,"unloaded"==h&&(h="loading",t(k,function(){h="loaded"})))};b.addEventListener("scroll",--> <!--l(m,q));b.addEventListener("resize",l(m,q));b.disqusLoader=function(a,c){var d={laziness:1,throttle:250,scriptUrl:!1,disqusConfig:!1},b=c,g,h={};for(g in d)Object.prototype.hasOwnProperty.call(d,g)&&(h[g]=d[g]);for(g in b)Object.prototype.hasOwnProperty.call(b,g)&&(h[g]=b[g]);c=h;n=c.laziness+1;m=c.throttle;p=c.disqusConfig;k=!1===k?c.scriptUrl:k;e="string"===typeof a?f.querySelector(a):"number"===typeof a.length?a[0]:a;e.disqusLoaderStatus="unloaded";q()}})(window,document,0);--> <!--</script>--> <!--<script>--> <!-- disqusLoader( '.disqus',--> <!-- {--> <!-- scriptUrl: '//{"shortname"=>"dev-diary-2"}.disqus.com/embed.js',--> <!-- disqusConfig: function()--> <!-- {--><script src="//ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script> $(document).ready(function () { $(".loader").hide(); });</script><script> $("#search-input").keyup(function () { $("main").hide(); $("search-container").show(); if (!$('#search-input').val()) { $("main").show(); $("search-container").hide(); } });</script><script src="/js/jekyll-search.min.js" type="text/javascript"></script><script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-container'), searchResultTemplate: '<a class="nostyle" href="{url}"><div class="blog borders cards"><div class="image" style="background-image: url({image});"></div><div class="content"><h3 class="title">{title}</h3><p class="description">{description}</p></div></div></a>', noResultsText: 'No results found', json: '/search.json' })</script><script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script><script> AOS.init({ duration: 600, once: true, disable: 'mobile' });</script><script> $("button").click(function () { $(".disqus").toggle(); $(".comments").toggle(); });</script></body></html>