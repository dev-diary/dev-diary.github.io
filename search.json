[
  
    {
      "category" : "java, Design patterns, interview",
      "title"    : "Kill the virus with a strategy pattern! Java Strategy Pattern with practical examples",
      "description": "Strategy Design Pattern in JavaTodat I‚Äôll take you to my lab. I‚Äôll show you h...",
      "content": "Strategy Design Pattern in JavaTodat I‚Äôll take you to my lab. I‚Äôll show you how to make your code cleaner. Any project can be created by multiple programmers at the same time, and each of them makes more bricks - being forced to understand other people‚Äôs bricks.Because you are in my lab, we will start working on real examples - starting with eccomerce, ending with virus treatment!Strategy Pattern introductionThe strategy pattern next to the factory pattern is one of the most frequently used design patterns. It is easy to understand and to implement. It is one of the behavioral patterns, i.e. those that describe certain behavior.Strategy defines a family of interchangeable algorithms (in the form of classes) that are used to solve the same problem in several different ways.ImplementationThe Context class contains a reference to the StrategyInterface strategy object. The strategy object can be injected by the constructor or setter. The Context class method uses the strategy object to finalize the operation.  Strategy classes Strategy1, Strategy2, etc. implement StrategyInterface interface methods. Each of these implementations of StrategyInterface solves a similar problem in a slightly different way. The above diagram can be implemented in the following way:      public class Context {    private Strategy strategy;    public Context(Strategy strategy) {        this.strategy = strategy;    }    public void setStrategy(Strategy strategy) {        this.strategy = strategy;    }    public void run(Object args) {        strategy.action(args);    }}  // -----------------------------------------------------------  public class Strategy1 implements Strategy {     @Override  public void action(Object args) { //do action specific for Strategy1  }}    // -----------------------------------------------------------   public class Strategy2 implements Strategy {     @Override  public void action(Object args) { //do action specific for Strategy2  }}  // -----------------------------------------------------------   interface Strategy {     void action(Object args);}  Before calling the target method, the client selects the injected strategy depending on the condition:  Context context = new Context(new Strategy1());  String arg = &quot;args passed to strategy 1&quot;;  context.run(arg);    //new conditions context.setStrategy(new Strategy2());  arg = &quot;args for strategy 2&quot;;  context.run(arg);  Strategy Pattern Real Life ExamplesLet‚Äôs get to the practical part. I will show you some examples where Strategy pattern is a perfect solution.E-commerce - international shipping system with the strategy patternImagine that we own an online shop with many different products. At the beginning, we send products only to the USA, but we want to enter a new market - Europe. We also plan to enter the Australian and African markets. By following the Open/Closed Principle we do not want to add more IFs to our class. In this case, the ideal choice is the strategy pattern!Let‚Äôs start from the Shopping.java interface - responsible for price calculation and currency information.      public interface Shopping {     double calculatePrice(List&amp;lt;Product&amp;gt; products);  Currency getCurrency(); }  Now it‚Äôs time for some boring model classes:Products.java with our products:      public class Product {     private int id;  private String name;  private double price;  private Size size;    public Product(int id, String name, double price, Size size) {  this.id = id;  this.name = name;  this.price = price;  this.size = size;  } // getters and setters Cart.java class:      public class Cart {    private Shopping shopping;    private List&amp;lt;Product&amp;gt; products;    public Cart(Shopping shopping) {        this.shopping = shopping;        products = new ArrayList();    }    public double getTotalPrice() {        return shopping.calculatePrice(products);    }    public void addProduct(Product product) {        products.add(product);    }}Size.java - The price of the products will depend on the size:      public enum Size {    S(1),    L(2),    XL(3);    private int size;    Size(int size) {        this.size = size;    }    @Override    public String toString() {        switch(size) {            case 1:                return &quot;S&quot;;            case 2:                return &quot;L&quot;;            case 3:                return &quot;XL&quot;;            default:                return &quot;CUSTOM&quot;;        }    }}Let‚Äôs get back to the concrete!  It‚Äôs time to implement our strategies. Depending on the country of shipping, the relevant customs duty is charged and the shipping cost of EuropeShopping, AmericaShopping increases. Large products (XL-size) have an additional charge.      public class AmericaShopping implements Shopping {    private final double USD_TAX = 0.75;    private final double DUTY_TAX = 1.0;    private double DELIVERY_COST = 15;    @Override    public double calculatePrice(List&amp;lt;Product&amp;gt; products) {        double totalPrice = 0;        for(Product product : products) {            if(product.getSize() == Size.XL) {                totalPrice += product.getPrice() * DUTY_TAX;                DELIVERY_COST += 10;            }            else {                totalPrice += product.getPrice() * DUTY_TAX;                DELIVERY_COST += 5;            }        }        return (totalPrice + DELIVERY_COST) * USD_TAX;    }    @Override    public Currency getCurrency() {        return Currency.USD;    }}  public class EuropeShopping implements Shopping {    private final double DUTY_TAX = 1.5;    private double DELIVERY_COST = 11;    @Override    public double calculatePrice(List&amp;lt;Product&amp;gt; products) {        double totalPrice = 0;        for(Product product : products) {            totalPrice += product.getPrice() * DUTY_TAX;            if(product.getSize() == Size.XL)                DELIVERY_COST += 10;        }        return totalPrice;    }    @Override    public Currency getCurrency() {        return Currency.EUR;    }}The above listing shows the calculation of the final price depending on the location of the shipment and product size. Example of use:      public class Main {    public static void main(String[] args) {        Shopping shopping;//       Define a region for the USA.//       This is for demo purposes only - it should be injected depending on user address.        Region region = Region.EUR;//      Choice of strategy according to user region        if(region == Region.USA) {            shopping = new AmericaShopping();        }        else {            shopping = new EuropeShopping();        }        Cart cart = new Cart(shopping);        cart.addProduct(new Product(0, &quot;Dell&quot;, 125, Size.L));        cart.addProduct(new Product(1, &quot;Iphone&quot;, 1235, Size.S));        cart.addProduct(new Product(2, &quot;TV&quot;, 535, Size.XL));        double totalPrice = cart.getTotalPrice();        System.out.println(&quot;Total price : &quot; + totalPrice + &quot; &quot; + shopping.getCurrency());//        for region = REGION.USA the result is: Total price : 1447.5 USD//        for region = REGION.EUR the result is: Total price : 2842.5 EUR    }}Number converter with the strategy patternImagine that you want to create a system to convert numbers into different Numeral Systems .As in the previous example, we will start with the interface:      public interface ConvertingStrategy {      String convert(int number);  }  Time for implementation. We will add support to convert number to octal, binary and hex system:      public class BinaryConverter implements ConvertingStrategy {      public String convert(int number) {          return Integer.toBinaryString(number);      }  }    public class HexaConverter implements ConvertingStrategy {      public String convert(int number) {          return Integer.toHexString(number);      }  }    public class OctaConverter implements ConvertingStrategy {      public String convert(int number) {          return Integer.toOctalString(number);      }  }  According to the diagram at the beginning of the post - we will create a class Context that will use our strategies:      public class Context {    private ConvertingStrategy strategy;    public Context(ConvertingStrategy strategy) {        this.strategy = strategy;    }    public String convert(int number) {        return strategy.convert(number);    }}An example of how to use a strategy to convert:      public class Main {      public static void main(String[] args) {          Context ctx = new Context(new HexaConverter());          System.out.println(ctx.convert(1000));  //      Result: 3e8  //      If you change HexaConverter to BinaryConverter, the result will be: 1111101000      }  }  Cure the Coronavirus with strategy pattern!It‚Äôs time for something popular :) We will create a strategy to treat viruses. It may seem to you that this is not a very practical use of Strategy Pattern, but imagine a similar situation in any game.In our case, this could be part of a game taking place in a Hospital For Infectious Diseases!Very often the strategy is used in games to handle movement. We want a player to either walk or run when he moves, but maybe in the future, he should also be able to swim, fly, teleport, burrow underground, etc.Let‚Äôs return to the hospital game. Just like before, we start with the interface:      public interface VaccinationStrategy {      String vaccineInjection();  }  And some implementations:      public class Covid19Treatment implements VaccinationStrategy {      public String vaccineInjection() {          return &quot;The patient have been cured of infection with Coronavirus&quot;;      }  }    public class EbovTreatment implements VaccinationStrategy {      public String vaccineInjection() {          return &quot;The patient have been cured of infection with Ebov&quot;;      }  }    public class SarsTreatment implements VaccinationStrategy {      public String vaccineInjection() {          return &quot;The patient have been cured of infection with SARS&quot;;      }  }  Now let‚Äôs create a class that will work as the Context from the previous point. Let‚Äôs name it Treatment.java:      public class Treatment {    private VaccinationStrategy vaccinationStrategy;    private String patientName;    public Treatment(String patientName) {        this.patientName = patientName;    }    public void setVaccination(VaccinationStrategy vaccination) {        this.vaccinationStrategy = vaccination;    }    public void treatment() {        System.out.println(&quot;The treatment of the patient: &quot; + this.patientName + &quot; has started&quot;);        System.out.println(vaccinationStrategy.vaccineInjection());        System.out.println(&quot;The patient left the hospital&quot;);        System.out.println(&quot;--------------------------------------------------------------------&quot;);    }}In the above example, we set the strategy through the setter (instead of the constructor). Example of use:   public class Main {    public static void main(String[] args) {        Treatment patient1Treatment = new Treatment(&quot;John Duke&quot;);        Treatment patient2Treatment = new Treatment(&quot;Elisa Muratti&quot;);        Treatment patient3Treatment = new Treatment(&quot;Jeff People&quot;);        patient1Treatment.setVaccination(new Covid19Treatment());        patient2Treatment.setVaccination(new EbovTreatment());        patient3Treatment.setVaccination(new SarsTreatment());        patient1Treatment.treatment();        patient2Treatment.treatment();        patient3Treatment.treatment();        System.out.println(&quot;All patients cured. The world is saved!&quot;);    }//    RESULT://The treatment of the patient: John Duke has started//    The patient have been cured of infection with Coronavirus//    The patient left the hospital//--------------------------------------------------------------------//    The treatment of the patient: Elisa Muratti has started//    The patient have been cured of infection with Ebov//    The patient left the hospital//--------------------------------------------------------------------//    The treatment of the patient: Jeff People has started//    The patient have been cured of infection with SARS//    The patient left the hospital//--------------------------------------------------------------------//    All patients cured. The world is saved!}Tax calculation system with the Strategy PatternWe have a system for creating invoices, but we have customers from different tax zones. What do you think will be the right design pattern? Exactly, the strategy!This time our interface will have one method of calculate():      public interface Tax {      BigDecimal calculate(Invoice invoice);  }    // IMPLEMENTATIONS:  public class DutyTax implements Tax {      public BigDecimal calculate(Invoice invoice) {          return invoice.getCost()                  .multiply(BigDecimal.valueOf(0.18));      }  }    public class FederalTax implements Tax {      public BigDecimal calculate(Invoice invoice) {          return invoice.getCost()                  .multiply(BigDecimal.valueOf(0.07));      }  }    public class VatTax implements Tax {      public BigDecimal calculate(Invoice invoice) {          return invoice.getCost()                  .multiply(BigDecimal.valueOf(0.10));      }  }  We‚Äôll need the class responsible for the invoice:      public class Invoice {    private BigDecimal cost;    public Invoice(BigDecimal cost) {        this.cost = cost;    }    public BigDecimal getCost() {        return cost;    }    public void setCost(BigDecimal cost) {        this.cost = cost;    }}And, as before, the Context class:        public class Context {      private Tax tax;     public Context(Tax tax) { this.tax = tax; }   public BigDecimal calculateTax(Invoice invoice) { return tax.calculate(invoice); }}  Example of use:      public class Main {    public static void main(String[] args) {        Invoice invoice = new Invoice(new BigDecimal(&quot;1500&quot;));        Context federal = new Context(new FederalTax());        Context vat = new Context(new VatTax());        Context duty = new Context(new DutyTax());        System.out.println(federal.calculateTax(invoice));        System.out.println(vat.calculateTax(invoice));        System.out.println(duty.calculateTax(invoice));//        Result://        105.00//        150.0//        270.00    }}The most popular use of the Strategy Pattern in JavaThere are a lot of examples to come up with. The most common situations in which the strategy pattern is used are:  Validation:  You need to check items according to some rule, but it is not yet clear what that rule will be, and there are likely to be many of them.  Storing information: You want the application to store information to the Database, but later it may be neet to be able to save a file.  Games: as I wrote in previous point - strategy is often used in games, e.g. to correctly handle the movement of objects in games.  Sorting: You want to sort elements, but you do not know what sorting algorithm should you use (BrickSort, QuickSort or other).  This is a common case used in examples of Strategy implementation, so I omitted implementation in this article.  Outputting: You need to output text as a plain string, but later may be a CSV, XML or PDF.Examples of Strategy Pattern in Spring Framework and Java librariesThe strategy is a pattern that you often use using different librarians/frameworks in Java. The best example of the strategy pattern is the Collection.sort() method that takes Comparator parameter.  We do not need to change the sort() method to achieve different sorting results. We can just inject different comparators in runtime.The next example is javax.servlet.Filter#doFilter() method. In Spring Framework an example of using strategy is class: org.springframework.web.servlet.mvc.multiaction.MethodNameResolverSummaryThat‚Äôs all about the Strategy Design PatternüôÇLink to Github with all examples: Github",
      "url"      : "/blog/Java-Strategy-Design-Pattern-By-Examples/",
      "image"    : "/images/strategy-pattern/header-image.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "java, concurrency, interview",
      "title"    : "Multithreading in Java. Java synchronization and concurrency. The most important information for a Java Developer interview",
      "description": "Introduction to Java ThreadsBeing a Java programmer, most of us have had any ...",
      "content": "Introduction to Java ThreadsBeing a Java programmer, most of us have had any contact with multithreading. One of the biggest challenges is to properly synchronize the code between threads. Fortunately, the language developers have prepared for us a full set of tools that help us achieve this goal. If you are curious or you are preparing for an interview - read this post.Application without multithreadingSingle-threaded programs are simple applications that do not require concurrent execution of tasks. Each of the tasks is run after the previous one is finished. It looks like this:These rectangles represent three tasks to be performed. The length of the rectangles represents the duration of each task. The tasks are started one by one - after the green task ends, the red task begins. You can say that the tasks are executed sequentially.Application with multithreadingWhat is a Java ThreadsThe threads are a way for the processor to do many things at once. At a given point in time, the processor can only do as many instructions as it has cores (it‚Äôs more complicated, but this simplification will allow us to explain more easily). This would mean that you could only have as many programs running at once as you have processor cores - usually two or four on modern computers. To work around this limitation, the processor runs on threads - one program is one (or more) threads.From the developer‚Äôs point of view, a thread is a set of instructions that he/she is going to write in the application, and execute in a certain way. An application itself can be composed of several threads and different threads can be executed at the same time.What is Time SlicingGoing further, does that mean we can only run one thread on a single-core processor? And on a dual-core processor, two threads? Not exactly. This problem was solved by creating a time-slicing mechanism. A mechanism that allows one processor core to run multiple threads. However, this does not happen in parallel.The image below shows the tasks from the previous point. This time each of them is run in a separate thread, so we have three threads.  The mechanism that supervises their work (Thread Scheduler) ensures that from time to time the current thread is stopped. Another thread is woken up, gets processor time and is executed by it. This is known as Context switch. The sum of the lengths of rectangles in a given color is the same as in the previous example.It should be remembered that such an approach does not speed up the execution of tasks (it takes time to stop and wake up the threads) - but it does allow to process each ‚Äúrectangle‚Äù a bit. For what purpose? Imagine such tasks:The green rectangle is a task to open the browser with the last tabs saved (one million tabs).In the meantime, the user presses the night-mode button, which is a very quick task (red rectangle). Unfortunately, it has to wait until the browser is finished opening tabs. Only then will the next task be executed.The same task can be split, and even though each task will take the same amount of time - the user will start the night-mode much faster. He will not have to wait for the browser to open:This approach avoids starving the threads. In the above example, without time slicing, the thread with the green task would starve the threads with the blue and red tasks.Multi-threading on multicore processorsMulti-core processors give you the real ability to run multiple tasks in parallel. In this case, if each of the tasks is run in a separate thread, the situation looks like in the picture below:In your applications, you‚Äôll meet a combination of both approaches. The image below shows an example of how the task is executed on two cores.Concurrency vs ParallelismAs I mentioned earlier, parallel tasks are only possible on a multi-core CPU. It is important to remember that  When there is just one processor, the OS scheduler context switchesbetween different threads to provide concurrent execution.and  When there are multiple CPUs, each CPU essentially runs an instance ofthe OS scheduler, thereby executing threads that are waiting to berun. The result is parallel execution of the set of threads to beexecuted.Concurrent data processingThe threads use the same data (they share the address space). This means that objects available for one thread are also visible in other threads.Variables are available for all threads. Therefore, all threads can modify these variables. This has very serious consequences. I will describe them in more detail later in this post.Java Thread creationEvery thread in Java is related to the Thread class. There are several ways to create a thread.Extending Thread classThe first way is to create your class, which inherits from Thread class:    public class FirstThread extends Thread {    @Override    public void run() {          System.out.println(&quot;Heellooo!&quot;);    }  }    // Creating Thread  Thread thread = new FirstThread();In this case, you have to override run() method - it will be executed in a thread.Extending the Thread class is not good practice. Note that in Java each class can extend only one class. When you extend the Thread class, after that you can‚Äôt extend any other class which you required.Additionally, extends in Java is used to add/modify some functionality from a subclass.  In this case, we do not add/modify anything to Thread class.Implementation of the Runnable interfaceThe second way is to create a thread using the Thread‚Äôs constructor, which accepts the object implementing the Runnable interface:    public class FirstThread implements Runnable {    @Override    public void run() {          System.out.println(&quot;Heellooo from Runnable :)&quot;);    }  }    // Creating Thread  Thread thread = new Thread(new FirstThread());This time the body of the thread is the implementation of the run() interface method (the thread will run this method and will work until it is done).Note that you can create a thread using anonymous classes:    Thread newThread = new Thread(new Runnable() {    @Override    public void run() {          System.out.println(&quot;Hello from the thread!&quot;);    }  });Additionally, the Runnable interface is a function interface. Therefore, this can be simplified by using lambda expressions: Thread newThread = new Thread(() -&amp;gt; System.out.println(&quot;Hello from the thread!&quot;));Creating threads in ExecutorServiceExecutorService is an interface that we do not have to implement on our own, the Java provides us with ready-made implementations. Thanks to that we can easily create a thread or a pool of threads, which will work according to our expectations. The most important methods that this interface provides are:submit(Runnable task) - allows you to send ‚Äòtask‚Äô (implementation of the Runnable interface) to be executed (note: we have no guarantee that it will be started immediately! It depends on the current status of ExecutorService, task queue, available threads, etc).shutdown() - allows you to finish threads correctly, previously completing all tasks and releasing all resources. Calling this method is required before the application is finished!A detailed explanation of how ExecutorService works and examples will be presented in the next post.The Java thread‚Äôs life cycleCreating a thread is just the beginning. Each thread has its life cycle. Threads can be in one of six states. Permissible states of the thread are in the Thread.State enumeration class:  NEW - a new thread that has not yet been launched,  RUNNABLE - a thread that can execute its code,  TERMINATED - a thread that has ended,  BLOCKED - thread blocked, waiting for the release of the sharedresource,  WAITING - a thread goes to wait state once it calls wait() on an Object. Once a thread reaches waiting state, it will need to wait till some other thread calls notify() or notifyAll() on the object.  TIMED_WAITING - a thread is waiting for a certain time.The change from the NEW state to the RUNNABLE state is made after calling the start() method on the thread instance. Only then the thread can be executed. Each thread can be run exactly once - the start() method can be called on it only once. Otherwise, the IllegalThreadStateException exception will be thrown.Synchronization in JavaRace ConditionYou already know that threads share the address space. I‚Äôve described it in the subsection #concurrent-data-processing. It has very important consequences.  See the example below:class Counter {      private int value;     public void increment() {          value++;    }        public int getValue() {          return value;    }  }    public class RaceCondition {      public static void main(String[] args) throws InterruptedException {          Counter counter = new Counter();    Runnable r = () -&amp;gt; {              for (int i = 0; i &amp;lt; 50000; i++) {                  counter.increment();    }          };      Thread t1 = new Thread(r);    Thread t2 = new Thread(r);    Thread t3 = new Thread(r);      t1.start();    t2.start();    t3.start();      t1.join();    t2.join();    t3.join();      System.out.println(counter.getValue());    }  }As you can see I used a Thread.joint() method. This method ensures that the current thread waits for the end of the thread on which the joint was called.  the default main thread waits for the end of the t1 thread, when t1 ends - waits for t2 to end, then it waits for t3 end (the order may be different).There are three threads in the above code, each of them 50 000 times increment the value of the variable by 1, so the finish counter value should be 150 000, right? Try to run this code several times. What results do you get? In my case, the results were returned:  111772  102556  132565  92146What you‚Äôve seen above is race condition. This happens if several threads at the same time modify a variable that is not adapted to such a parallel change. But why did the value attribute have such different values? This is because the value++ operation (value = value + 1) is not an atomic operation.  An atomic operation is an operation that is indivisible. An atomicoperation is performed by a single instruction in the bytecode (in acompiled class).The execution of value++ (value = value + 1) operation consists of several steps:  Get the current value to a temporary variable (not visible in the source code),  Add 1 to the temporary variable,  Assigning an increased value to value variable.In the previous subsection, I described time-slicing. It plays a key role here.  Imagine a situation in which the T1 thread execute steps 1, 2 and 3 and was context-switching started. Then threads T2 and T3 took step 1. Then thread T2 took steps 2 and 3. After a while, the same happened to thread T3. As a result, threads overwrite outdated values. One of the scenarios is shown in the table below:            Operation      Thread      Step      Value variable      Temp variable value                  1.      T1      1.      0      0              2.      T1      2.      0      1              3.      T1      3.      1      1              4.      T2      1.      1      1              5.      T3      1.      1      1              6.      T2      2.      1      2              7.      T2      3.      2      2              8.      T3      2.      2      2              9.      T3      3.      2      2      In the example above, operation 9. sets the value to 2 in the T3 thread ignoring the increase in value made by the T2 thread in operation 7.To avoid race condition, it is necessary to synchronize the threads.Java Threads SynchronizationIn general, thread states are intuitive. The descriptions in the previous section help you understand what happens to a thread in a given state. Well, maybe apart from the BLOCKED state. When is the thread BLOCKED?A thread that is in the BLOCKED state is waiting for a blocked resource. In Java, blocking is done with monitors, which are used to synchronize the threads.  Each object in Java is associated with a monitor, which a thread can lock or unlock. The monitor can only be blocked by one thread at a time. Thanks to this, objects are used to synchronize threads. For this purpose, the synchronized keyword is used.Synchronized blockWith a synchronized block, you can be sure that everything inside the block is running on up to one thread at a time.Try to run the modified example from the previous subsection several times:class Counter {      private int value;     public void increment() {          synchronized (this) {              value++;    }      }        public int getValue() {          return value;    }  }Each time the application returns the correct result - 150 000.Synchronized methodYou can also use the synchronized keyword for the method:public synchronized void increment() {    value ++;}In practice, both versions of the increment method are equivalent. Marking the method with the synchronized keyword is equivalent to placing the whole body of the method in the synchronized block. Which object is used as a monitor depends on the type of method:  standard method - a class (this) instance is used as a monitor.  static method - the whole class is used as a monitor  Remember not to abuse synchronized. The code in a synchronized blockcan only be executed by one thread (it loses the possibility ofconcurrent execution), which makes the execution of such a program slower.Use synchronized only in places where it is necessary.Java Thread in WAITING stateOne of the ways to put the thread in WAITING state is to call the Object.wait() method. What the wait() method does?Imagine a situation where you have two threads. One produces some data, the other consumes it (Producer-Consumer Pattern). The data-consuming thread (T2) uses a while loop, which is executed until the expected number of items is taken from the queue. The program works. However, it has a subtle problem. Consumer thread works all the time. It takes up CPU time continuously! What‚Äôs more, for most of its time, it revolves inside the loop, checking if there are any new messages in the queue. How can this problem be solved? One way may be to put the consumer‚Äôs thread to sleep using the Thread.sleep() method. This would also be a waste of time - how do you know how long it will take to produce the next message? For this purpose, it is better to use the notification mechanism.Thread NotificationAll Java objects, except monitors, contain a special wait set. The elements of this set are threads that wait for notification about this object. The only way to modify the content of waiting set is to use methods available in the Object class:  Object.wait() - adding the current thread to the waiting set threads,  Object.notify() - notification and waking up one of the pending threads,  Object.notifyAll() - to notify and wake up all pending threads.The producer from the previous section should use the notify or notifyAll method to inform consumers of the new message. Consumers should use the wait method so that they can wait for notifications from the producer.Interruption of the threadInterruption of a thread is indicated by an InterruptedException exception .  A thread can be interrupted when Thread.interrupt method is called on its instance. When a thread is interrupted, a special flag is set on it, which informs about it (Thread.interrupted).Java Volatile keywordJava provides another mechanism which is connected to synchronization - volatile. The Java specification says that every read of an attribute preceded by this keyword follows its writing. In other words, the volatile modifier ensures that every thread reading a given attribute will see the latest saved value of that attribute.However, you have to watch out for modifications that are not atomic - unfortunately, volatile will not protect you. In this case, you will need the synchronization described earlier.Volatile --&amp;gt; Guarantees visibility and NOT atomicitySynchronization (Locking) --&amp;gt; Guarantees visibility and atomicity (if done properly)You‚Äôre probably wondering what this mechanism is for and what the risk is not using volatile. Imagine a multi-threaded application on a single-core processor:The variables are copied from the main memory to CPU cache (due to a much faster access to the CPU cache compared to RAM access time), Now the threads access the memory from the CPU cache rather than computer memory to save time and increase the performance.There‚Äôs nothing dangerous here. Let‚Äôs go to the 2-core processor:In Multi-CPU computer each thread may run in different CPUs, which means, that each thread may copy the variables into the CPU cache of different CPUs.Imagine a situation in which two or more threads have access to a shared object which contains a value variable from the previous point:class Counter {      public int value;  }Now, T1 and T2 can have different CPU cores. When T1 will make changes to value variable - the changes have occurred in CPU cache and there is no guarantee that every change in CPU cache will be reflected to the Main Memory immediately.So when T2 tries to read the updated value variable value from the main memory, T2 may or may not find the updated value.To protect from this problem, just use the volatile keyword.  volatile is keyword used with variable to make sure the value are readfrom and written to main memory rather than CPU cache.This ensures that you get the ‚Äúreally‚Äù correct value of the variable.SummaryAs you can see, there are many thread synchronization mechanisms available in Java. Please take a look at them to better decide which ones to use when.If you want to know more about concurrency, there will be a post about ExecutorService soon!",
      "url"      : "/blog/Java-Interview-Questions-Multithreading/",
      "image"    : "/images/concurrency/concurrency-header-image.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "java, interview",
      "title"    : "Java Recruitment Questions - hashCode() method explained in detail",
      "description": "Questions about hashCode() are asked on most interviews (from junior to senio...",
      "content": "Questions about hashCode() are asked on most interviews (from junior to senior level). In this post, you will find out what this method is, how it works for particular types, how it works for primitives, what you have to watch out for during your implementations. Enjoy reading!What is hashCode() methodhashCode() is a method that should contain a hash algorithm that calculates a 32-bit integer (hash) from the object data, representing that object.This hash is used by some collections (e.g. HashMap and HashSet) to store references to objects, so that access to data is very fast. Access time depends on the performance of our hash algorithm, so it is worth paying attention to it!Do java primitive types have their hashcode()?Primitive types are not treated the same as ordinary objects. It is not possible to call the hashCode() method on a primitive type. The only option is to use wrappers such as Integer.hashCode(3). Integer.hashCode() returns the value of the int we passed on to the method (in our case 3). Implementation of hashCode from Integer class:public static int hashCode(int value) {    return value;    }Similar hashcode() functionality  exists in the Short and Byte classes. First it casts short/byte to the int and returns its value.A little different hashCode() is in Long. Since Long is a 64-bit number we have to do some ‚Äúcompression‚Äù so that we can return the int value:         public static int hashCode(long value) {        return (int)(value ^ (value &amp;gt;&amp;gt;&amp;gt; 32));    }  The &amp;gt;&amp;gt;&amp;gt; is the right shift bit operation. value &amp;gt;&amp;gt;&amp;gt; 32means that we shift 32 bits to right. It leave only 32 bits - and the rest of the position is completed by 0 (32 rightmost bits are discarded). Then, on shifted value a XOR operation is performed ^.Float numbers are more complicated.  Java convert its floating-point values to an equicalent integer value using Float.floatToIntBits(float value). The method also checks whether the value is NaN (Not-a-number):     public static int hashCode(float value) {        return floatToIntBits(value);    }      public static int floatToIntBits(float value) {        if (!isNaN(value)) {            return floatToRawIntBits(value);      }        return 0x7fc00000;    }        public static boolean isNaN(float v) {        return (v != v);    }    public static native int floatToRawIntBits(float var0);  Implementation of floatToRawIntBits() depend on the JVM/JDK you are using. For openJDK the source is here.Double convert its floating-point value to long using doubleToLongBits() then does the same XOR trick as Long.Does the Java enums have its hashCode() ?Enums uses Object‚Äôs hashCode() . This is the only way to use hashCode() in the enum.     public final int hashCode() {        return super.hashCode();    }  In addition, Enum‚Äôs hashcode() is final to prevent developers from creating their own implementations. It is because within one JVM there can exist only one instance of each enum object (enums are singletons). This is enough to ensure that such implementation makes sense and is correct.hashCode() method in Java arraysArrays do not provide its hashCode() implementation. Just as enums use a method from the Object class.It can cause a lot of problems because this hash depends on the magic described below. A better practice is to use hashCode() from the helper class - Arrays.  Arrays.hashCode() method returns a hash code based on the contents of the specified array. If the contents of the two arrays are equal then return the same value. You can see an example below:     int [] numbers1 = new int[]{1,2,3,4,5,6};    int [] numbers2 = new int[]{1,2,3,4,5,6};        System.out.println(numbers1.hashCode()); // return 1595428806    System.out.println(numbers2.hashCode()); // return 1072408673        System.out.println(Arrays.hashCode(numbers1)); // return 918073252    System.out.println(Arrays.hashCode(numbers2)); // return 918073252      Array class has several hashCode() methods - for primitive types (e.g. hashCode(float a[]), hashCode(int a[])), which inside use type specific hashcode() from the wrapper classes. For other Objects it use:    public static int hashCode(Object a[]) {        if (a == null)            return 0;         int result = 1;         for (Object element : a)            result = 31 * result + (element == null ? 0 : element.hashCode());         return result;    }  As you can see, this method adds all the hash from all elements by multiplying them by a multiplier - which in this case is 31. You may be wondering why we need a multiplier of 31. Thanks to the multiplier, arrays with the same elements but different order has different hashcodes.  For example, having a table with the elements [10,20] and [20,10] - without a multiplier, hashcode for the first table would be: 1 + 10 + 20 = 30, and for the second table: 1 + 20 + 10 = 30. Both tables would have the same hashcode (30) even though the order of their elements is different. With a multiplier, their hashcode is - for the first array: (31*1 + 10) *31+20 = 1291 and for the second array: (31*1 + 20) *31+10 = 1591If you are interested in why the multiplier is 31 - this is described in detail in the article. I recommend reading it!hashCode() method in List, Map, SetArrayList and LinkedList use the same algorithm as Arrays.hashCode() for the same reason. Set, unlike List, uses hashcode() without multiplier:    public int hashCode() {        int h = 0;      Iterator&amp;lt;E&amp;gt; i = iterator();     while (i.hasNext()) {            E obj = i.next();     if (obj != null)                h += obj.hashCode();      }        return h;    }  In Set a multiplier is not needed - as the order of the elements does not matter (it is the same). This makes the hashCode calculation a bit faster.In Maps, hashCode adds all element hashes (element hash is xor from the key hash and hash values).hashCode() method in StringThis is String class hashCode() implementation:    public int hashCode() {     if (h == 0 &amp;amp;&amp;amp; !hashIsZero) {            h = isLatin1() ? StringLatin1.hashCode(value)                           : StringUTF16.hashCode(value);     if (h == 0) {                hashIsZero = true;      } else {                hash = h;      }        }        return h;    }  If the string has Latin encoding, the StringLatin1.hashCode method is used, and if the string is UTF-16 encoding, the hashcode will be generated in tringUTF16.hashCode. The difference is that in latin1 each character is exactly one byte long. In utf8 a character can consist of more than one byte.  Inside, the hashCode calculating functionality is the same as in List or Arrays.hashCode().The advantage of the hashCode from the String class is that the hashcode value is cached and calculated lazily during the first call of the method.hashCode() method in java ObjectsIf your class hasn‚Äôt overridden the hashCode() method, then it will use the one defined in its super class, probably in the Object class. hashCode() in Object class is a native function (is dependant on the JVM). Documentation says :  As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the JavaTM programming language.)It is hard to guess how exactly hashCode() works, as its implementation is placed in the native code of the JVM. In many places, you can find information that hashCode() is simply an address in memory.  Given that the JVM can relocate objects (e.g. during garbage collection cycles due to promotion or compaction) - after we calculate an object‚Äôs identity hash we must be able to retain it in a way that survives object relocation.One solution is to write the hashcode calculated during the first call of the hashCode() method into the object data (e.g object header). This way, if the object is moved to another memory area, it will still have the same, original hashcode. But despite the fact that it is often believed that - this is not the functionality of the most popular JVM implementation - OpenJDK‚Ä¶How is the hashCode calculated? hashCode() JVM implementationIf we go deeper, to the JVM code (the implementation can be found here - line 511) we can deduce that the hashCode is not calculated from the address in the memory but from the thread state! You can find proof of that on StackOverflow.There are two important things to remember. First of all, such hashCode calculating exist from OpenJDK 8. Secondly, hashCode calculating is implementation-dependent. In this post we checked OpenJDK. For comparison - JVM Zing implementation calculates hashCode based on a memory address. This can be considered a tricky recruitment question!  :)hashCode() own implementationsFinally, it is important to mention the good practices when creating your own hashCode().I will share with you the 3 most common ways to create your own hashCode():  Using IDE (e.g. generating in IntelliJ, you can press ALT + Insert and select ‚Äúequals and hashCode‚Äù from the context menu).  Using libraries. For example, Lombok library, which will generate hashCode() during compilation.  Writing your own implementation of hashCode() - you must be careful not to make a mistake. A wrong hashCode() can spoil the effectiveness of HashMap and bring many problems!A simple example! Everyone likes simple examples! We have a well-known Person class:    public class Person {    private String name;    private String surname;    public Person(String name, String surname) {        this.name = name;        this.surname = surname;    }    @Override    public int hashCode() {        return Objects.hash(name, surname);    }}  Remember that when overwriting the hashCode() method you must also overwrite the equals() method, so as not to break the hashCode() &amp;amp; equals() contract. The equals and hashCode methods should meet the following conditions:If x == y then x.equals(y) == trueIf x.equals(y) == true then x.hashCode() == y.hashCode()If x.hashCode() == y.hashCode() then x.equals(y) can either return true or return falseThe last point is based on int scope (hashCode() returns int value). As a result, hashCode() can return a finite number of results: from -2 147 483 648 to +2 147 483 647 - so, around 4 billion unique values. Let‚Äôs imagine, that we are building the application, that keeps more data. If we start invoking the hashCode() method from more than 4 billion elements, it is possible, that first 4 billion ones will produce a unique result, but each next call will produce the integer value, that has been produced before. Therefore, it is important to combine hashCode() with equals() to make sure that objects that have the same hashcodes are not different.Additional hashCode() doubtsDo I have to implement hashCode/equals in each class?Answer: No, if you don‚Äôt expect to use the equals method (e.g., aren‚Äôt using assertEquals from JUnit, or never mean to use this class as a key in a Map, etc), the implementation will not be used -&amp;gt;  it not necessary.What will be the effect of badly implemented hashCode()Anwer: Even if in hashCode you will return the same int for each element, e.g:    @Override    public int hashCode() {        return 123;    }  Your program will compile and run. The problem can be when you want to use collections using hashCode (HashMap, HashSet or other). In the above example hashCode - all elements will be placed into the same bucket in HashMap (as LinkedList elements). Effectiveness will decrease significantly.Does null have its hashCode?Of course you can‚Äôt call the hashCode() method (like any other method) on null value. But we can pass null to Objects.hashCode():    public static int hashCode(Object o) {      return o != null ? o.hashCode() : 0;  }  As you can see, Objects.hashCode() for null will return 0. You‚Äôre probably wondering how HashMap‚Äôs doing in that case.  HashMap has a special handling for null keys. null values are fine as you don‚Äôt compute hash code for them in a HashMap. This is the reason why null keys work fine in HashMap.SummaryI hope you liked the article. If you have any questions, please feel free to comment. Thank you for your comments under the last post :)",
      "url"      : "/blog/Java-Recruitment-Questions-HashCode/",
      "image"    : "/images/hashcode/hashcode-header-image.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "java, interview",
      "title"    : "Java Recruitment Questions - Immutable Objects",
      "description": "Java Recruitment Questions - Immutable ObjectsIn Java, object variability is ...",
      "content": "Java Recruitment Questions - Immutable ObjectsIn Java, object variability is something very common. Until recently, it was normal for most beans to have getters and setters (In many projects this trend is still continuing).Increasingly, at interviews, interviewers ask: ‚ÄúWhat are immutable objects and what are their advantages and disadvantages?‚ÄùWhat is an immutable object?An immutable object is one which, after being created and initialized, remains unchanged and, importantly, cannot be changed (in a conventional way, of course). This means that such an object does not provide methods that allow changing its state. And all its fields are private (or public final).This changeability is a little apparent, because, using reflection, you can change the field values in each class. However, this does not mean that for this reason, we should give up immutable objects.How to ensure the object‚Äôs immutability?Apart from the fact that all fields should be private, they should be final. And the class itself should be marked as final so that it cannot be inherited. Such an object should not provide methods to modify its internal state, e.g. setters.But private, final fields are not everything. It is important what types of data we store in these fields. It should also be unchangeable! If the fields in your object are primitives, primitive wrappers or Strings then there is no problem. All these types are immutable. But if you use your own objects, you must ensure that they are unchangeable.If you use a collection, you must also ensure that it remains immutable. There are several possibilities:  You can use special methods from the Collections class that return an appropriate unmodified view of the collection:          static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; unmodifiableList(List&amp;lt;? extends T&amp;gt; list)      static &amp;lt;T&amp;gt; Set&amp;lt;T&amp;gt; unmodifiableSet(Set&amp;lt;? extends T&amp;gt; s)      static &amp;lt;K,V&amp;gt; Map&amp;lt;K,V&amp;gt; unmodifiableMap(Map&amp;lt;? extends K,? extends V&amp;gt; m) Each of these methods takes a list, a set or a map as an argument and returns the list, set or map with the same content as the argument, but different from the original in that the attempt to change them, for example add or remove, causes an exception UnsupportedOperationException        Use the immutable collections. If you are using Java 8 or above, you must use a library that will provide you with an implementation of the unchanging collections (e.g. Guava). If you are using newer versions of Java (9+), you have a collection that is immutable in the standard packages, e.g. List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);. In Java 10, there are also copyOf(...) methods that allow you to copy the standard collection and convert it to the fixed one.If you use a primitive array - you have a little problem because the arrays are inherently changeable. And using them in immutable objects is pointless. Of course, when creating an object, we can copy all arrays, but this does not change the fact that the copied arrays are also changeable. In this case, it is best to use the collection.How to create immutable objects?Such objects can be created in three ways. Through the constructor and that is the easiest way. But it has a fundamental disadvantage. The more fields to initiate, the more parameters in the constructor. That‚Äôs why you shouldn‚Äôt create objects that have more than 2-3 fields.          public final class Animal {    private final String name;    private final String ownerName;    public Animal(String name, String ownerName) {        this.name = name;        this.ownerName = ownerName;    }    public String getName() {        return name;    }    public String getOwnerName() {        return ownerName;    }}// CreationAnimal animal = new Animal(&quot;Tina&quot;, &quot;John&quot;);Another way is the factory method. As with the constructor, the more fields, the more parameters. But this approach has such an advantage that we can create several such methods with a different names, with different set of parameters, which improves readability.A third way to create immutable objects is to use the builder pattern. In order to use the builder, it must be implemented inside the class so that it has access to private class fields.          public final class User {    private int age;    private String firstName;    private String lastName;    public static Builder builder() {        return new Builder();    }    public static class Builder {        private User user = new User();        public Builder firstName(String firstName) {            user.firstName = firstName;            return this;        }        public Builder lastName(String lastName) {            user.lastName = lastName;            return this;        }        public Builder age(int age) {            user.age = age;            return this;        }        public User build(){            return user;        }    }// Creation User user = User.builder()                .firstName(&quot;John&quot;)                .lastName(&quot;People&quot;)                .age(45)                .build();We can write such a builder manually or use some kind of IDE plugin to generate it for us. Another option is to use Lombok and @Builder annotation.Advantages of immutable objectsThese objects make us avoid accidental changes, often in very inappropriate places. If an object is changeable, there will definitely be someone who wants to change it where it should not.A good example of such a situation is the object that we pass as a parameter of the method. Such an object can be passed between multiple application layers, between multiple method calls. It can be passed on very deep in the call hierarchy. This makes it very difficult to identify where it was changed. This can lead to many strange and difficult to solve problems.Using immutable objects we do not have such problems and the design of our application improves.Invariant objects are also safe for multithreaded use. If an object is not changed, it can be safely transferred between threads without synchronization.Another advantage is that such objects are ideal as key objects in maps. In a situation where keys are variable, after changing the key object its hashcode changes, making it impossible to find the stored value in HashMap.Disadvantages of immutable objectsWriting this post I didn‚Äôt think about the disadvantages of creating immutable classes. Fortunately, a user potracheno informed about it in the comment. Thanks!Immutable objects have far more advantages than disadvantages. The only thing that comes to my mind is the cost of memory. With immutability, any time you need to modify data, you need to create a new object. This can be expensive. If you are sure that you will not need immutability (e.g. you are creating a simple single-threaded application) - do not create immutable code.When to use immutable objects?You can use the same objects anywhere and anytime. You don‚Äôt have to use multithreading to use immutable objects. Applications that work in one thread also gain a lot when using immutable objects.SummaryImmutable objects are a very important element of application building, which makes applications more legible and consistent, as well as more error-proof. Every developer should know how to use immutable objects and what benefits are associated with their use.",
      "url"      : "/blog/Java-Recruitment-Questions-Immutable-Objects/",
      "image"    : "/images/immutable-objects/header-image.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "kubernetes, prometheus",
      "title"    : "Metrics from unstructured logs on Kubernetes. Sidecar pattern with grok exporter - Part 2",
      "description": "In previous post, you have looked into Prometheus basics. In this part, it is...",
      "content": "In previous post, you have looked into Prometheus basics. In this part, it is time to create Prometheus service on the Kubernetes which can scrape metrics from additional metric exporter.  It‚Äôs the perfect solution when you can‚Äôt export metrics from the application source code and your application logs the information you want to  expose as metrics.Example Spring application with loggingTo understand how an grok exporter works, we must first create an application that logs some data to files.I have prepared a very simple application in Spring Boot that has two functionalities:      Welcomes users entering the home page. If the user does not provide his name in @RequestParam - the application will answer: Hello Guest        HelloController source code: Github        Every 10 seconds creates a log in the form: DATE TIME SERVICE_NAME CONNECTION_TIME.  Service names are randomly selected from 3 defined names. Response times are also random. The logs are supposed to resemble real logs of the application connecting to other services and measuring the time of connection. The source code is on the GithubLogs are saved to the logs/applog.log file. Log4j configuration:log4j.xml code: GithubApplication code is also available on Github, docker image is on dockerHub.Deploy a Spring Boot Application on KubernetesFirstly, we have to build docker image with application. I have already done it -  image is pushed to the DockerHub. You can just import the image in the deployment definition (image: docker.io/michf/spring-logging-app:latest) for Kubernetes to deploy application.If you want to create an image of your own application you can create a Dockerfile based on mine and push to the Dockerhub.Now, we have to prepare Kubernetes deployment configuration. Let‚Äôs start from the Deployment config:           apiVersion: apps/v1          kind: Deployment          metadata:            name: spring-logging-app            labels:              app: spring-logging-app          spec:            replicas: 1            selector:              matchLabels:                app: spring-logging-app            template:              metadata:                labels:                  app: spring-logging-app              spec:                containers:                  - name: spring-logging-app                    image: docker.io/michf/spring-logging-app:latest                    ports:                      - containerPort: 8080Service definition: apiVersion: v1kind: Servicemetadata:  name: spring-logging-appspec:  type: ClusterIP  ports:    - protocol: TCP      targetPort: 8080      port: 8080    selector:        sidecar: spring-logging-appThat‚Äôs all. You can deploy logging application on Kubernetes.Deploy a Grok Exporter as a sidecar on KubernetesWe will be collecting data from our logs using a sidecar container. A sidecar container is a secondary container which is run within the same Pod.  In our case grok exporter will be a sidecar container.To configure sidecar pattern, we will create a volume (with /logs path) for our Pod to be shared by all containers in the Pod. Then we will configure grok exporter to read logs from shared location.Firstly, we have to create grok service. Service will be a target in Prometheus: apiVersion: v1kind: Servicemetadata:  name: grok-exporter  labels:    sidecar: grok-exporterspec:  type: ClusterIP  ports:    - protocol: TCP      targetPort: 9144      port: 9144    selector:        sidecar: grok-exporter9144 is a default grok exporter port.Log capture using grok exporter in KubernetesTo capture logs we need to create a configuration file.  For this purpose we will use Kubernetes ConfigMap: kind: ConfigMapmetadata:  name: grok-exporterapiVersion: v1data:  config.yml: |-    global:      config_version: 2    input:      type: file      fail_on_missing_logfile: false      path: /logs/applog.log    grok:      patterns_dir: ./patterns    metrics:      - type: histogram        name: service_call        help: Services call times        match: &#39;%{DATE} %{TIME} %{WORD:service} connection time= %{INT:val}&#39;        value: &#39;&#39;  buckets: [100, 1000, 3000]    labels:      service    :&#39;{{.service}}&#39;    - type: counter      name: hello_requests_total      help: Hello controller requests counter      match: &#39;%{DATE} %{TIME} HelloController request from: %{USER:user}&#39;      labels:        user    : &#39;{{.user}}&#39;    server:      port: 9144Configmap will create and mount the config.yml file (configuration for grok exporter). In config.yml we set the path to the mounted volume (/logs/applog.log) and two types of metrics. The histogram will inform you about how many connections to external services took less than 100 ms, how many calls took more than 100, but less than 1000, and how many calls lasted more than 3000 ms. Counter will inform you how many http requests has served our application for a given user.The match: property is an expression pattern. You can find all grok patterns on the Github.Then you can adjust the pattern to catch your logs.Let‚Äôs add volume and grok exporter image to the deployment definition from previous point: apiVersion: apps/v1kind: Deploymentmetadata:  name: spring-logging-app  labels:    app: spring-logging-appspec:  replicas: 1  selector:    matchLabels:      app: spring-logging-app      sidecar: grok-exporter  template:    metadata:      labels:        app: spring-logging-app        sidecar: grok-exporter    spec:      containers:        - name: spring-logging-app          image: docker.io/michf/spring-logging-app:latest          ports:            - containerPort: 8080          volumeMounts:            - name: logs              mountPath: /logs/                - name: grok          image: palobo/grok_exporter          imagePullPolicy: Always          ports:            - containerPort: 9144              protocol: TCP          volumeMounts:            - name: grok-config-volume              mountPath: /etc/grok_exporter            - name: logs              mountPath: /logs            volumes:                - name: grok-config-volume          configMap:                name: grok-exporter                    - name: logs          emptyDir: {}Now, we can deploy above Deployment.  After entering the pod via Kubernetes Dashboard, you should see information about two containers (from grok and from the logging application):Let‚Äôs check if grok expese endpoint wiht metrics. I used kubectl port-forward pod-name port:port to forward a grok port to localhost kubectl port-forward spring-logging-app-79bb56876-c4h29 9144:9144     You can go to 127.0.0.1:9144/metrics and check the application metrics based on the logs:.Counter metrics:Histogram metrics:Deploy a Prometheus on KubernetesPrometheus ConfigMapFirstly, create a configmap with the Prometheus scrape config: apiVersion: v1kind: ConfigMapmetadata:  name: prometheusdata:  prometheus.yml: |-    global:      scrape_interval: 15s    scrape_configs:    - job_name: &#39;grok&#39;      static_configs:      - targets: [&#39;grok-exporter:9144&#39;]Prometheus will collect information from the grok-exporter service every 15 seconds.Prometheus DeploymentIn Prometheus deployment config We have to mount created a moment ago config map as a file inside /etc/prometheus: apiVersion: apps/v1kind: Deploymentmetadata:  name: prometheusspec:  selector:    matchLabels:      app: prometheus  replicas: 1  template:    metadata:      labels:        app: prometheus    spec:      containers:        - name: prometheus          image: prom/prometheus:v2.12.0          ports:            - name: web              containerPort: 9090          volumeMounts:            - name: prometheus-config              mountPath: /etc/prometheus            - name: prometheus-data              mountPath: /prometheus            volumes:                - name: prometheus-data          emptyDir: {}                    - name: prometheus-config          configMap:                  name: prometheusPrometheus ServiceTo acces the Prometheus GUI over an IP/DNS, we need to expose it as a  service: apiVersion: v1kind: Servicemetadata:  name: prometheus  labels:    app: prometheusspec:  selector:    app: prometheus  type: NodePort  ports:    - protocol: TCP      name: web      nodePort: 31199      port: 9090      targetPort: 9090SummaryNow we can access the Prometheus dashboard using kubectl port-forward  9090:9090. You should see the Prometheus dashboard with scraped data:Thank you for reading! I hope you enjoyed the post.",
      "url"      : "/blog/Prometheus-On-Kubernetes-Part-2/",
      "image"    : "/images/prometheus-kubernetes/prometheus-kubernetes2.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "kubernetes, prometheus",
      "title"    : "A quick introduction to Prometheus. Metrics on Kubernetes with grok exporter - Part 1",
      "description": "Prometheus is one of the most popular open-source systems for monitoring and ...",
      "content": "Prometheus is one of the most popular open-source systems for monitoring and alerting. Very often it is used to collect data from microservices in Kubernetes. In this series you will learn the main blocks of Prometheus: metrics and labels, push and pull information exchange. You will learn how to use Prometheus without changing the application code. We will generate metrics based on logs (in our case, performance logs).Prometheus metrics and labelsMetrics are the main concept of Prometheus. Instrumented applications expose them by HTTP endpoint or JMX. Prometheus ‚Äúscrapes‚Äù and stores them in the time-series database. This means that it works very well in a distributed, cloud-native environment. All of the services are unburdened by a load on the monitoring system. Metric is an identifier of data collected by Prometheus. The metric specifies the general feature of a system that is measured - for example http_requests_total - the total number of HTTP requests received. Labels can be added to each data point to specify which service this counter applies to:Imagine a request counter that looks like this:http_requests_total{service=&quot;spring-app&quot;}There are many spring-app instances in the cluster so we should add another label - instance:http_requests_total{service=&quot;spring-app&quot;, instance=&quot;spring-app-1&quot;}We can add many other labels that accurately describe the request (HTTP method, endpoint, response HTTP status).  Metrics with good labels are key to the best use of Prometheus.Metrics typesCounterIt is the most popular metric type. Counter is an incremental value or zero (after initialization/restart). It is most often used to measure the number of requests, errors.GaugeGauge is the incremental/decremental value that changes over time. It is used for memory or CPU usage statistics.HistogramMetrics such as response time are most commonly monitored using histograms. Before starting measurements, we must first define the possible ranges of results. In the case of measuring the response time, it can be: below one second, between 1 second and 2 seconds, between 2 and 10 and above 10. Then we assign the observed value to the matching range.SummaryThe Summary type works very much like a histogram, but it is slightly more extensive, e.g. it stores information about the total number of observations.,Push and Pull Prometheus modelThe monitoring system based on Prometheus can collect metrics in two main ways: push or pull models.PushIn push model applications are active and they are responsible for sending collected records to Prometheus via Pushgateway. This model works best for gathering information, e.g. with test results, or other cyclical tasks that can be performed irregularly and for a longer period.PullIn this model, the application is passive and only prepares its metrics in the form of an endpoint. Prometheus decides when to download them. This approach is recommended by application developers and should be used in most cases.Exposing and scraping metricsMost languages have an implementation of Prometheus client with functionalities for:      Getting metrics for the language (JVM metrics, GC metrics, Go metrics)        Possibility to registry custom metrics        HTTP handler to create and expose metrics on the /metrics endpoint    Prometheus scrapes each target regularly (the frequency of meter reading is set by scrape interval property)  Exporting metrics using side-cars containersSometimes it is impossible to instrument application at the code level.  In this case, the best solution is to use exporters as side-car containers. The most popular are Node exporter and Grok exporter which can read system metrics (CPU, memory‚Ä¶) and expose them for Prometheus.SummaryYou‚Äôve read the basics of Prometheus. You should have a better understanding of what Prometheus is and how it works. You will need this knowledge in the next post. I will show you how to use Grok exporter to instrument Java application based on application logs.",
      "url"      : "/blog/Prometheus-On-Kubernetes-Part-1/",
      "image"    : "/images/prometheus-kubernetes/prometheus-kubernetes1.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "kubernetes",
      "title"    : "Single Node Kubernetes Cluster - Deploying Kubernetes Dashboard",
      "description": "In the previous post, we have prepared an environment for work and installed ...",
      "content": "In the previous post, we have prepared an environment for work and installed Kubernetes and Docker. Now, we will deploy Kubernetes Dashboard.Deploy Kubernetes DashboardKubernetes Dashboard is web-based UI for Kbuernetes clusters. It allows to manage applications deployed in the cluster. Dashboard documentation is available at Kubernetes Github repo.Use the following command to deploy the dashboard on the cluster:     kubectl apply -f kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yamlTo access Dashboard from your Ubuntu you must create a secure channel to your Kubernetes cluster. Run the following command:kubectl proxyNow check in the new Putty window if dashboard is properly exposed:curl -I 127.0.0.1:8001You should see 200 OK Http response:michal@michal:~$ curl -I 127.0.0.1:8001HTTP/1.1 200 OKContent-Length: 2738Content-Type: application/jsonDate: Sun, 14 Jul 2019 10:07:39 GMTProxy to host WindowsWe will use the Windows browser to manage the cluster. To enable this run the following command in Ubuntu terminal:kubectl proxy --address 192.168.0.129 --accept-hosts &#39;^.*$&#39; --port=8001And go to http://192.168.0.129:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login in your browser on windows. You should have seen the dashboard login screen. Please remember to change my inet IP adrress 192.168.0.129 with your VM‚Äôs inet IP address. Creating a service account and a role binding in KubernetesTo log in to our dashboard we need a service accout and a role binding. To create a service account, use the following command:kubectl create serviceaccount --namespace kube-system admin-userAnd for role binding:kubectl create clusterrolebinding admin-user --clusterrole=cluster-admin --serviceaccount=kube-system:admin-userSign in to Kubernetes DashboardThere are several ways to log into the dashboard. We can genereate JWT token:kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#39;{print $1}&#39;)Copy generated token and use it when logging in to the dashboard:Unfortunately, dashboard is only available via localhost. We can not log into the dashboard from the host system (Windows):  Dashboard should not be exposed publicly using kubectl proxy commandas it only allows HTTP connection. For domains other than localhostand 127.0.0.1 it will not be possible to sign in. Nothing will happenafter clicking Sign in button on login page.So, we can create SSH tunnel or enable skip loging. I chose the second option:kubectl edit deployment/kubernetes-dashboard --namespace=kube-systemAdd --enable-skip-login to the deployment‚Äôs command line arguments:      containers:      - args:        - --auto-generate-certificates        - --enable-skip-login            # &amp;lt;-- add this lineNow refresh the dashboard and click on the ‚Äúskip‚Äù button. You will be correctly logged into the dashboard:SummaryWe have already configured a single node cluster and a dashboard thanks. Now you can manage your applications in Kubernetes. If you have any problems, I invite you to comment.",
      "url"      : "/blog/Single-Node-Kubernetes-Cluster-Part-3/",
      "image"    : "/images/single-node-kubernetes/single-node-kubernetes.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "kubernetes",
      "title"    : "Single Node Kubernetes Cluster - Installing Docker and Kubernetes on Ubuntu Server",
      "description": "In the previous post, we have prepared an environment for work. Now we will b...",
      "content": "In the previous post, we have prepared an environment for work. Now we will be installing and configuring Docker and Kubernetes on our Ubuntu Server.Installing Docker and Kubernetes on Ubuntu ServerLet‚Äôs start with turning on the VM with Ubuntu Server and connecting via SSH to the machine (I described this in the previous post). First, use the following commands to install Docker:   curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;sudo apt update &amp;amp;&amp;amp; sudo apt install docker-ceThen use the following commands to install Kubernetes:   sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y apt-transport-https &amp;amp;&amp;amp; curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -echo &quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee -a /etc/apt/sources.list.d/kubernetes.list &amp;amp;&amp;amp; sudo apt-get updatesudo apt install -y kubeadm  kubelet kubernetes-cniIn the end, turn off the swap on Ubuntu Server because it is required in the changelog:   sudo swapoff -asudo sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstabThat‚Äôs all. Check if Docker and Kubernetes were installed using the commands:   docker -vand:   kubectl versionYou should see a similar result:   michal@michal:~$ docker -vDocker version 18.09.7, build 2d0083dmichal@michal:~$ kubectl versionClient Version: version.Info{Major:&quot;1&quot;, Minor:&quot;15&quot;, GitVersion:&quot;v1.15.0&quot;, GitCommit:&quot;e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2019-06-19T16:40:16Z&quot;, GoVersion:&quot;go1.12.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}Creating Single Node Kubernetes Cluster with KubeadmWe will use kubeadm which helps bootstrap Kubernetes cluster. Detailed documentation is available on the  kubernetes website. I will present some of the most important steps that will create a working cluster in a few minutes.At the beginning, install kubectl using the following command:   sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y apt-transport-https &amp;amp;&amp;amp; curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -echo &quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee -a /etc/apt/sources.list.d/kubernetes.list &amp;amp;&amp;amp; sudo apt-get updatesudo apt install -y kubeadm  kubelet kubernetes-cniNow we can create a single node cluster:   sudo kubeadm init --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.0.129 --ignore-preflight-errors=NumCPURemember to change ‚Äìapiserver-advertise-address=192.168.0.129 with your VM inet address. If you do not know how to check inet IP - read the instructions from the previous post.After a few minutes of installation, you should see the message: Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user:  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:  https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.0.129:6443 --token mc3oxw.8mkdwlr260ujpy6a \    --discovery-token-ca-cert-hash sha256:fbb8705c4826ece8596ee4eb14d0375677fed231bc2a3e78326bd46f3bb1f24eIn order for Kubernetes to work for a non-root user, you must run the following commands:   mkdir $HOME/.k8ssudo cp /etc/kubernetes/admin.conf $HOME/.k8s/sudo chown $(id -u):$(id -g) $HOME/.k8s/admin.confexport KUBECONFIG=$HOME/.k8s/admin.confecho &quot;export KUBECONFIG=$HOME/.k8s/admin.conf&quot; | tee -a ~/.bashrcConfiguring Kubernetes Cluster NetworkingAfter kubernetes installation, we need to configure networking. This is detailed in the documentation .Execute two commands to set the networking:   kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.ymlkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/k8s-manifests/kube-flannel-rbac.ymlMaster Node as a WorkerFinally, we have to use the kubectl taint command, so that our master node can create pods and be used as a worker node:   kubectl taint nodes --all node-role.kubernetes.io/master-SummaryThat‚Äôs all! We have created a working single node cluster. In the next post, I will show you how to create an admin dashboard in Kubernetes to be able to easily manage a cluster from the browser.",
      "url"      : "/blog/Single-Node-Kubernetes-Cluster-Part-2/",
      "image"    : "/images/single-node-kubernetes/single-node-kubernetes.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "kubernetes",
      "title"    : "Single Node Kubernetes Cluster - Installing Ubuntu Server on Windiws with Hyper-V",
      "description": "Today we will start playing with Kubernetes. We will start by installing Ubun...",
      "content": "Today we will start playing with Kubernetes. We will start by installing Ubuntu 19.04 Server on the Hyper-V virtual machine. Next, we will create a single node Kubernetes cluster. You can also use Minikube (a tool for running Kubernetes locally) for Windows instead of Ubuntu Server - but I wanted it to resemble a real development environment.We will use a ssh connection from windows to manage our cluster on Ubuntu Server.Requirements  Internet connection on the system that has Hyper-V installed.  Hyper-V enabledConfiguring Hyper-V Virtual Switch ManagerYour virtual machine will need access to your host windows‚Äô internet connection. To do this we must configure Virtual Switch Manager. Open the Hype-V panel and click on the ‚ÄúVirtual Switch Manager‚Äù:      Create a new External Virtual Switch:        Set a name and select your network adapter in the  External Network         Go to Control Panel\Network and Internet\Network Connections. You will see your newly created connection:        Right-click your Windows connection (In my case it is Ethernet). Click Properties, select Sharing tab and check the box All other network users to connect through this computers Internet connection.:  That‚Äôs all. Now you should have Internet access in your virtual machine.Creating Hyper-V virtual machineNow we can create VM with Ubuntu 19.04:  Open Start  Search for Hyper-V Manager  Select New and click on Virtual Machine:  Choose a name, leave the default Generation 1 option and click next.  Select the amount of RAM. I set 8192MB  Select the virtual switch which you created earlier:   On the Connect virtual hard disk tab you can set disk size. I allocated 25Gb.  On the Installation options tab select Install an operating system from a bootable CD/DVD-ROM option and provide a path for the Ubuntu ISO file. Click next and finish.Installing Ubuntu 19.04 Server using Hyper-V Virtual MachineWe have prepared a virtual switch and a virtual machine. Now we can install Ubuntu.  Open Hyper-V, right-click the newly created Virtual machine (in my case name is Ubuntu). Select Connect.  Click the Start:  Click the Install Ubuntu Server:  Leave default values in the next steps  Enter the username and password to your account  Set  Install OpenSSH server:  Restart the virtual machine to finish the setup.To connect to a ubuntu server in a virtual machine go to the Hyper-V -&amp;gt; Virtual Machines. Right-click on the virtual machine and then click on Connect.Connecting to Hyper-V Ubuntu Virtual Machine via SSHIn next posts, we will connect to the virtual machine via SSH. We will need two programs:  Putty - a free SSH client  WinSCP - a popular free SFTP client for Windows. We will use it to transfer files to the virtual machine.To connect to a virtual machine, run the ubuntu server in Hyper-V. After starting Ubuntu, enter the command in the terminal: ifconfigCopy inet IP and use it in Putty / WinSCP to connect to VM:Use the default settings and default port 22:Enter the user login and password you set during the Ubuntu installation to connect:After entering login details and clicking enter - you will get access to the Ubuntu Server in your Putty terminal.Connection via WinSCP looks the same as in the case of Putty.We already have a prepared environment. In the next post, we will set and configure a Kubernetes cluster.",
      "url"      : "/blog/Single-Node-Kubernetes-Cluster-Part-1/",
      "image"    : "/images/single-node-kubernetes/single-node-kubernetes.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "spring, java, react",
      "title"    : "Spring Boot 2 + PostgreSQL + JWT + React - Full Stack Web Development - Part 4 Creating a frontend in React",
      "description": "In previous posts, we have created a fully working application in Spring Boot...",
      "content": "In previous posts, we have created a fully working application in Spring Boot 2. Now it‚Äôs time to create a frontend that will communicate with our backend. If you have not read previous posts, I invite you to read.Requirements  Node and NPM installed (You can download it from here)Creating the React projectBefore we start coding, we have to create React project:  Open the shell terminal and execute the following command:npx create-react-app wallet-ui  Type following command: wallet-ui  Start npm by executing: npm startOn the  http://localhost:3000/ you should see the start page of the project in React:Changing the default appearanceOur design will be very simple. Our app.js looks like this:    import React, {Component} from &#39;react&#39;;import &#39;./App.css&#39;;class App extends Component {    render() {        return (            &amp;lt;div className=&quot;App&quot;&amp;gt;                &amp;lt;header className=&quot;Header&quot;&amp;gt;                    &amp;lt;h1 className=&quot;App-title&quot;&amp;gt;Currencies&amp;lt;/h1&amp;gt;                &amp;lt;/header&amp;gt;            &amp;lt;/div&amp;gt;        )    }}export default App;  And the App.css file:    .App {      text-align: center;    }        .Header {      background-color: rgba(169, 67, 63, 0.71);      height: 150px;      padding: 55px;      color: cornsilk;    }  Creating CRUD functionalitiesFirstly, we will create a component with the currencies table with paging, filtering and sorting rows/columns. In previous posts, we have created localhost:8080/currencies in our backend. Now we will use it to list all currencies in the frontend. We will start by creating a catalog for components. Create the components folder in the main project directory. Then create the Currencies.js file:Currencies.js will be our React component. A React component is a JavaScript class or function that optionally accepts inputs i.e. properties(props) and returns a React element that describes how a section of the UI  should appear:           import React, {Component} from &#39;react&#39;;class Currencies extends Component {    constructor(props) {        super(props);        this.state = {currencies: []};    }    render() {        return (            &amp;lt;div className=&quot;App&quot;&amp;gt;            &amp;lt;/div&amp;gt;        );    }}export default Currencies;           Now update the App.js adding a new component - the &amp;lt;Currencies /&amp;gt; :           import React, {Component} from &#39;react&#39;;import &#39;./App.css&#39;;import Currencies from &quot;./components/Currencies&quot;;class App extends Component {    render() {        return (            &amp;lt;div className=&quot;App&quot;&amp;gt;                &amp;lt;header className=&quot;Header&quot;&amp;gt;                    &amp;lt;h1 className=&quot;App-title&quot;&amp;gt;Currencies&amp;lt;/h1&amp;gt;                &amp;lt;/header&amp;gt;                &amp;lt;Currencies/&amp;gt;            &amp;lt;/div&amp;gt;        )    }}export default App;     Fetching data from the backendTo connect via HTTP we will use the Fetch API. The Fetch API provides the fetch() method of which we pass the path to the HTTP resource. In our case, it will be the URL of the backend:           fetch(&#39;http://localhost:8080/currencies&#39;)              .then((response) =&amp;gt; response.json())              .then((responseData) =&amp;gt; {                  this.setState({                      currencies: responseData                  })              })   That‚Äôs all we need to do to get data from the external API. But when the data should be fetched? The best place to fetch data is componentDidMount(). React‚Äôs lifecycle method.  When this method runs, the component was already rendered with the render() method so we have a guarantee that data won‚Äôt be loaded until after the initial render.There is one more thing to keep in mind. We have secured our application using JWT. The above use of the fetch() method will not work. We need to add the Authorization header with the generated jwt token.I generated a JWT token with Postman, then I injected it as a header in the fetch() method (You must generate the JWT token yourself. I showed how to do it in the previous post).Now, we will add a simple display of the data fetched from the backend:    import React, {Component} from &#39;react&#39;;class Currencies extends Component {    constructor(props) {        super(props);        this.state = {currencies: []};    }    componentDidMount() {        fetch(&#39;http://localhost:8080/currencies&#39;, {headers: {&quot;Authorization&quot;: &quot;Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTU2MTM4OTMyNn0.tVF719msAK-lanUq_Joupae5K1c80EKrjWSeuALFQPP2pyHM2nTDM54dBcB40IrhwU5zIVP3aR82fb6EJqEc6Q&quot;} })            .then((response) =&amp;gt; response.json())            .then((responseData) =&amp;gt; {                this.setState({                    currencies: responseData                })            })            .catch(err =&amp;gt; console.error(err))    }    render() {        const tableRows = this.state.currencies.map((currency, index) =&amp;gt;            &amp;lt;tr key={index}&amp;gt;                &amp;lt;td&amp;gt;{currency.name}&amp;lt;/td&amp;gt;                &amp;lt;td&amp;gt;{currency.code}&amp;lt;/td&amp;gt;                &amp;lt;td&amp;gt;{currency.amount}&amp;lt;/td&amp;gt;                &amp;lt;td&amp;gt;{currency.rate}&amp;lt;/td&amp;gt;            &amp;lt;/tr&amp;gt;        );        return (            &amp;lt;div className=&quot;App&quot;&amp;gt;                &amp;lt;table&amp;gt;                    &amp;lt;tbody&amp;gt;{tableRows}&amp;lt;/tbody&amp;gt;                &amp;lt;/table&amp;gt;            &amp;lt;/div&amp;gt;        );    }}export default Currencies;   Result:Using the react-table to display dataWe will use React Table to display currencies. Reac Table allows to display tabular data client-side, and provides sorting, filtering, and pagination over that data. To install a react-table in our application, run the npm install reactable --save command in the main project directory and restart the application.Now we have to remove the current table in the render() method and define the new one with react-table. If you want to configure the table in a different way, read the following doc: https://www.npmjs.com/package/react-table.Updated render() method:    render(){    const columns = [{        Header: &#39;Currency&#39;,        accessor: &#39;name&#39;,        Cell: this.editable    }, {        Header: &#39;Code&#39;,        accessor: &#39;code&#39;,        Cell: this.editable    }, {        Header: &#39;Amount&#39;,        accessor: &#39;amount&#39;    }, {        Header: &#39;Rate&#39;,        accessor: &#39;rate&#39;    }        ,];    return (        &amp;lt;div&amp;gt;            &amp;lt;ReactTable data={this.state.currencies} columns={columns} filterable={true}/&amp;gt;        &amp;lt;/div&amp;gt;    );}  The effect looks much better:Add new currency functionalityLet‚Äôs add functionality to adding new currencies. We will start with creating a new component - AddCurrency.js in the components directory. We will implement an add functionality with React Skylight component. SkyLight is a simple react component for modals and dialogs. Install a component like a react-table: npm install react-skylight --saveThe following source code shows the AddCurrency.js code:    import React, {Component} from &#39;react&#39;;    import SkyLight from &#39;react-skylight&#39;;        class AddCurrency extends Component {         constructor(props) {        super(props);            this.state = {name: &#39;&#39;, code: &#39;&#39;, amount: &#39;&#39;, rate: &#39;&#39;};        }            handleChange = (event) =&amp;gt; {            this.setState(                {[event.target.name]: event.target.value}            );        };            handleSubmit = (event) =&amp;gt; {            event.preventDefault();            var currency = {name: this.state.name, code: this.state.code, amount: this.state.amount, rate: this.state.rate};            this.props.addCurrency(currency);            this.refs.addDialog.hide();        }            render() {            return (                &amp;lt;div&amp;gt;                    &amp;lt;SkyLight hideOnOverlayClicked ref=&quot;addDialog&quot;&amp;gt;                        &amp;lt;h3&amp;gt;Add Currency&amp;lt;/h3&amp;gt;                        &amp;lt;form&amp;gt;                            &amp;lt;input type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; onChange={this.handleChange}/&amp;gt;&amp;lt;br/&amp;gt;                            &amp;lt;input type=&quot;text&quot; placeholder=&quot;Code&quot; name=&quot;code&quot; onChange={this.handleChange}/&amp;gt;&amp;lt;br/&amp;gt;                            &amp;lt;input type=&quot;text&quot; placeholder=&quot;Amount&quot; name=&quot;amount&quot; onChange={this.handleChange}/&amp;gt;&amp;lt;br/&amp;gt;                            &amp;lt;input type=&quot;text&quot; placeholder=&quot;Rate&quot; name=&quot;rate&quot; onChange={this.handleChange}/&amp;gt;&amp;lt;br/&amp;gt;                            &amp;lt;button onClick={this.handleSubmit}&amp;gt;Add&amp;lt;/button&amp;gt;                        &amp;lt;/form&amp;gt;                    &amp;lt;/SkyLight&amp;gt;                    &amp;lt;div&amp;gt;                        &amp;lt;button style={ {&#39;margin&#39;: &#39;10px&#39;} } onClick={() =&amp;gt; this.refs.addDialog.show()}&amp;gt;Add currency&amp;lt;/button&amp;gt;                    &amp;lt;/div&amp;gt;                &amp;lt;/div&amp;gt;            )        }            }        export default AddCurrency;  We added the form inside the render(). It contains the Skylight component with buttons and the input fields for adding the currency. We also added a button that opens the modal window - it will be shown in the Currencies component.Import the AddCurrency component inside the Currencies.js by adding:    import AddCurrency from &#39;./AddCurrency&#39;;  And update the render() method in the Currencies.js with addCurrency component:    return (        &amp;lt;div&amp;gt;            &amp;lt;AddCurrency addCurrency={this.addCurrency}  fetchCurrencies={this.fetchCurrencies}/&amp;gt;            &amp;lt;ReactTable data={this.state.currencies}  columns={columns}  filterable={true}/&amp;gt;        &amp;lt;/div&amp;gt;    );  After refreshing the page you should see the ‚ÄúAdd Currency‚Äù button. After clicking on it, you will see a window with inputs to complete:Edit and Remove functionalityCurrencies can be deleted/updated in the database by sending the DELETE/PUT HTTP method request to the backend. We will start by adding new columns with buttons to the react-table using Cell . We do not want to enable sorting and filtering functionalities for this column so we have to set props to false. The final code of the table is shown below:    render() {         const columns = [{                Header: &#39;Currency&#39;,            accessor: &#39;name&#39;,            Cell: this.editable     }, {            Header: &#39;Code&#39;,            accessor: &#39;code&#39;,            Cell: this.editable      }, {            Header: &#39;Amount&#39;,            accessor: &#39;amount&#39;      }, {            Header: &#39;Rate&#39;,            accessor: &#39;rate&#39;      }, {            sortable: false,            filterable: false,            width: 100,            Cell: row =&amp;gt; (                &amp;lt;div&amp;gt;                    &amp;lt;button onClick={() =&amp;gt; this.onDelClick(row.original.id)}&amp;gt;Delete&amp;lt;/button&amp;gt;                &amp;lt;/div&amp;gt;            )        }, {            sortable: false,            filterable: false,            width: 100,            Cell: row =&amp;gt; (                &amp;lt;div&amp;gt;                    &amp;lt;button onClick={() =&amp;gt; this.updateCurrency(row.original)}&amp;gt;Save&amp;lt;/button&amp;gt;                &amp;lt;/div&amp;gt;            )        }         ,]        return (            &amp;lt;div&amp;gt;                &amp;lt;AddCurrency addCurrency={this.addCurrency}  fetchCurrencies={this.fetchCurrencies}/&amp;gt;                &amp;lt;ReactTable data={this.state.currencies}  columns={columns}  filterable={true}/&amp;gt;            &amp;lt;/div&amp;gt;    ); }  Now, we have to implement two methods: onDelClick() and updateCurrency().  After each change, we need to re-collect currencies from the backend. In order not to repeat the code, let us move the functionality to fetch the data for the separate method fetchCurrencies():    fetchCurrencies = () =&amp;gt; {        fetch(&#39;http://localhost:8080/currencies&#39;,            {headers: {&quot;Authorization&quot;: &quot;Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTU2MTIyNDA3MH0._AdhZ_KDhWRmaxejYht9qtViH0TfouGUxQPCC12U_UPKLNYf7QafjtiP_BkSt8i_wNrHk4E4mzaPXErsjDH0_g&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}})            .then((response) =&amp;gt; response.json())            .then((responseData) =&amp;gt; {                this.setState({                    currencies: responseData                })            })            .catch(err =&amp;gt; console.error(&quot;error: &quot; + err));    }  The onDelClick() method implementation:    onDelClick = (id) =&amp;gt; {        if (window.confirm(&#39;Are you sure to delete currency?&#39;)) {            fetch(&#39;http://localhost:8080/currencies/&#39; + id, {                method: &#39;DELETE&#39;,                headers: new Headers({                    &quot;Authorization&quot;: &quot;Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTU2MTEwNTA0MH0.9PF5R4DA6rZQhoOLBn1l48VW4sgGmYjca8abazExtYxhCh9I5oV2z1_Ywalu46xioKph0Zo7OEXIb96WeNoALw&quot;      })            }).then(res =&amp;gt; this.fetchCurrencies())                .catch(err =&amp;gt; console.error(err));        }    };  And the onDelClick() method implementation:    updateCurrency(currency) {        fetch(&#39;http://localhost:8080/currencies&#39;, {            method: &#39;PUT&#39;,            headers: {                &quot;Authorization&quot;: yourJWT,                &quot;Content-Type&quot;: &quot;application/json&quot;      },            body: JSON.stringify(currency)        })            .then(res =&amp;gt; this.fetchCurrencies())            .catch(err =&amp;gt; console.log(err))    }  Finally, we need to add the editable function, which will allow us to edit the table‚Äôs cells:      editable = (cell) =&amp;gt; {        return (            &amp;lt;div style={ {backgroundColor: &quot;#fafafa&quot;} } contentEditable suppressContentEditableWarning onBlur={e =&amp;gt; {                const curr = [...this.state.currencies];                curr[cell.index][cell.column.id] = e.target.innerHTML;                this.setState({currencies: curr});            }}                 dangerouslySetInnerHTML={ {__html: this.state.currencies[cell.index][cell.column.id]} }            /&amp;gt;        );    };Buttons appeared. The functionality for editing and deleting data works correctly!Adding login functionality with JWTFor the application to work properly, we still need to implement the user‚Äôs login functionality. Let‚Äôs start by creating a new Login.js component in the components folder:    import React, {Component} from &#39;react&#39;;class Login extends Component {    constructor(props) {        super(props);        this.state = {username: &#39;&#39;, password: &#39;&#39;, isAuthenticated: false, open: false};    }    render() {        return (            &amp;lt;div&amp;gt;            &amp;lt;/div&amp;gt;        );    }}export default Login;  We are going to use bootstrap styles in the Login page. Install the following component: npm install --save bootstrap and add import &#39;bootstrap/dist/css/bootstrap.min.css&#39;; at the beginning of Login.js.Update render() method by adding login form:    render() {        if (this.state.isAuthenticated === true) {            return (&amp;lt;Currencies /&amp;gt;)        }        else {            return (                &amp;lt;div id=&quot;login&quot;&amp;gt;                    &amp;lt;h3 className=&quot;text-center text-white pt-5&quot;&amp;gt;Login form&amp;lt;/h3&amp;gt;                    &amp;lt;div className=&quot;container&quot;&amp;gt;                        &amp;lt;div id=&quot;login-row&quot; className=&quot;row justify-content-center align-items-center&quot;&amp;gt;                        &amp;lt;div id=&quot;login-column&quot; className=&quot;col-md-6&quot;&amp;gt;                         &amp;lt;div id=&quot;login-box&quot; className=&quot;col-md-12&quot;&amp;gt;                        &amp;lt;div className=&quot;form-group&quot;&amp;gt;                            &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; onChange={this.handleChange}  className=&quot;form-control&quot; placeholder=&quot;username&quot; /&amp;gt;                        &amp;lt;/div&amp;gt;                        &amp;lt;div className=&quot;form-group&quot;&amp;gt;                            &amp;lt;input type=&quot;password&quot; name=&quot;password&quot; onChange={this.handleChange}  className=&quot;form-control&quot; placeholder=&quot;password&quot; /&amp;gt;                        &amp;lt;/div&amp;gt;                             &amp;lt;input type=&quot;submit&quot; name=&quot;submit&quot; onClick={this.login}  className=&quot;btn btn-info btn-md&quot; value=&quot;Login&quot;/&amp;gt;                         &amp;lt;/div&amp;gt;                        &amp;lt;/div&amp;gt;                        &amp;lt;/div&amp;gt;                &amp;lt;/div&amp;gt;                &amp;lt;/div&amp;gt;         );} }  If the user is already authenticated (isAuthenticated is true), the Currencies component will be displayed. Let‚Äôs now implement the methods used in the form.The handleChange() method for handling the changes from the form:    handleChange = (event) =&amp;gt; {        this.setState({[event.target.name] : event.target.value});    }  And the login function:    login = () =&amp;gt; {        const user = {userName: this.state.username, password: this.state.password};        fetch(&quot;http://localhost:8080/&quot; + &#39;login&#39;, {            method: &#39;POST&#39;,            body: JSON.stringify(user)        })            .then(res =&amp;gt; {                const jwtToken = res.headers.get(&#39;Authorization&#39;);                if (jwtToken !== null) {                    sessionStorage.setItem(&quot;jwt&quot;, jwtToken);                    this.setState({isAuthenticated: true});                }                else {                    this.setState({open: true});                }            })            .catch(err =&amp;gt; console.error(err))    };  The login is done by calling the /login endpoint with the POST HTTP method (we are sending the user object inside the request body). If the backend authenticates the provided user, we get an Authorization header in the response. We get a JWT token and save to session storage.Now we need to update App.js to display the &amp;lt;Login /&amp;gt; component instead of &amp;lt;Currencies /&amp;gt;:    import React, {Component} from &#39;react&#39;;    import &#39;./App.css&#39;;    import Login from &#39;./components/Login&#39;        class App extends Component {        render() {            return (                &amp;lt;div className=&quot;App&quot;&amp;gt;                    &amp;lt;header className=&quot;Header&quot;&amp;gt;                        &amp;lt;h1 className=&quot;App-title&quot;&amp;gt;Currencies&amp;lt;/h1&amp;gt;                    &amp;lt;/header&amp;gt;                    &amp;lt;Login/&amp;gt;                &amp;lt;/div&amp;gt;            )        }    }        export default App;  We also have to update the Currencies.js so that each time we use thefetch()method, it retrieves the JWT from sessionStorage and sends it to the Authorization header. The following source code shows the Currencies.js final code:   import React, {Component} from &#39;react&#39;;    import ReactTable from &quot;react-table&quot;;    import &#39;react-table/react-table.css&#39;;    import AddCurrency from &#39;./AddCurrency&#39;;        class Currencies extends Component {        constructor(props) {            super(props);            this.state = {currencies: []};        }         componentDidMount() {         this.fetchCurrencies();        }            onDelClick = (id) =&amp;gt; {            const jwtToken = sessionStorage.getItem(&quot;jwt&quot;);            if (window.confirm(&#39;Are you sure to delete currency?&#39;)) {                fetch(&#39;http://localhost:8080/currencies/&#39; + id, {                    method: &#39;DELETE&#39;,                    headers: new Headers({                        &quot;Authorization&quot;: jwtToken,                        &quot;Content-Type&quot;: &quot;application/json&quot;     })                }).then(res =&amp;gt; this.fetchCurrencies())                    .catch(err =&amp;gt; console.error(err));            }        };         addCurrency(currency) {         const jwtToken = sessionStorage.getItem(&quot;jwt&quot;);            fetch(&#39;http://localhost:8080/currencies/&#39;, {                method: &#39;POST&#39;,                headers: {                    &quot;Authorization&quot;: jwtToken,                    &quot;Content-Type&quot;: &quot;application/json&quot;     },                body: JSON.stringify(currency)            })                .then(res =&amp;gt; this.fetchCurrencies())                .catch(err =&amp;gt; console.log(err))        }         updateCurrency(currency) {         const jwtToken = sessionStorage.getItem(&quot;jwt&quot;);            fetch(&#39;http://localhost:8080/currencies&#39;, {                method: &#39;PUT&#39;,                headers: {                    &quot;Authorization&quot;: jwtToken,                    &quot;Content-Type&quot;: &quot;application/json&quot;     },                body: JSON.stringify(currency)            })                .then(res =&amp;gt; this.fetchCurrencies())                .catch(err =&amp;gt; console.log(err))        }         editable = (cell) =&amp;gt; {        return (                &amp;lt;div style={ {backgroundColor: &quot;#fafafa&quot;} }  contentEditable suppressContentEditableWarning onBlur={e =&amp;gt; {                    const curr = [...this.state.currencies];                    curr[cell.index][cell.column.id] = e.target.innerHTML;                    this.setState({currencies: curr});                }}     dangerouslySetInnerHTML={ {__html: this.state.currencies[cell.index][cell.column.id]} }     /&amp;gt;            );        }             render() {            const columns = [{                Header: &#39;Currency&#39;,                accessor: &#39;name&#39;,                Cell: this.editable     }, {                Header: &#39;Code&#39;,                accessor: &#39;code&#39;,                Cell: this.editable      }, {                Header: &#39;Amount&#39;,                accessor: &#39;amount&#39;      }, {                Header: &#39;Rate&#39;,                accessor: &#39;rate&#39;      }, {                sortable: false,                filterable: false,                width: 100,                Cell: row =&amp;gt; (                    &amp;lt;div&amp;gt;                        &amp;lt;button onClick={() =&amp;gt; this.onDelClick(row.original.id)}&amp;gt;Delete&amp;lt;/button&amp;gt;                    &amp;lt;/div&amp;gt;                )            }, {                sortable: false,                filterable: false,                width: 100,                Cell: row =&amp;gt; (                    &amp;lt;div&amp;gt;                        &amp;lt;button onClick={() =&amp;gt; this.updateCurrency(row.original)}&amp;gt;Save&amp;lt;/button&amp;gt;                    &amp;lt;/div&amp;gt;                )            }         ,]            return (                &amp;lt;div&amp;gt;                    &amp;lt;AddCurrency addCurrency={this.addCurrency}  fetchCurrencies={this.fetchCurrencies}/&amp;gt;                    &amp;lt;ReactTable data={this.state.currencies}  columns={columns}  filterable={true}/&amp;gt;                &amp;lt;/div&amp;gt;            );        }            fetchCurrencies = () =&amp;gt; {            const jwtToken = sessionStorage.getItem(&quot;jwt&quot;);            fetch(&#39;http://localhost:8080/currencies&#39;,                {headers: {&quot;Authorization&quot;: jwtToken, &quot;Content-Type&quot;: &quot;application/json&quot;}}            )                .then((response) =&amp;gt; response.json())                .then((responseData) =&amp;gt; {                    this.setState({                        currencies: responseData                    })                })                .catch(err =&amp;gt; console.error(&quot;error: &quot; + err));    } }        export default Currencies;  By going to localhost:3000 you should see the login page. After entering the username and password (in our case, admin: admin - we have set this data in our backend) - you will be authenticated and you will have access to the application:SummaryCongratulations, we have created a fully working application, secured by JWT. In the next (last) post we will configure PostreSQL.The source code of the entire application (frontend and backend) is available on Github:  Frontend: Github Repo  Backend: Github Repo",
      "url"      : "/blog/Spring-Boot-2-PostgreSQL-JWT-React-Part-4/",
      "image"    : "/images/spring-react-currency-walet/header-image-part4.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "spring, java, react",
      "title"    : "Spring Boot 2 + PostgreSQL + JWT + React - Full Stack Web Development - Part 3 Spring Security with JWT",
      "description": "Our application already has a controller, thanks to which we can manage data ...",
      "content": "Our application already has a controller, thanks to which we can manage data using HTTP requests. However, we must set security so that only authorized persons can manage these data.Spring SecuritySpring Security provides security services for Spring-based applications:  Single sign-on  Protection against attacks like session fixation, clickjacking, cross-site request forgery, etc  Basic Access Authentication  Digest Access Authentication  Remember-me feature  Web Form Authentication  Authorization  HTTP AuthorizationYou can add Spring Security in your application by adding spring-boot-starter-security dependency to your pom.xml file. By the way, we‚Äôll also add dependency to JWT. We will need it later:       &amp;lt;dependency&amp;gt;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;        &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;        &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;    &amp;lt;/dependency&amp;gt;  &amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;0.9.1&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;WebSecurityConfigurerAdapter configurationTo configure Spring Security in our project, we have to add new configuration class that extends the WebSecurityConfigurerAdapter class in net.devdiaries.wallet.configuration package:       package net.devdiaries.wallet.configuration;        import org.springframework.context.annotation.Configuration;    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;            @Configuration    @EnableWebSecurity    public class SecurityConfiguration extends WebSecurityConfigurerAdapter {  }  The @Configuration and @EnableWebSecurity annotations provide the default security configuration.Now, we can define which endpoints should be secured. We have to override the configure(HttpSecurity HTTP method.Adding user/password featureWe can use an in-memory user provided by Spring Security, but the real backend application should save the users in the database. We are going to create an entity class for the user (User.java) and repository class. It will be very similar to creating Currency.java and CurrencyRepository in the first post:1 - User.java in the net.devdiaries.wallet.domain package:       package net.devdiaries.wallet.domain;        import lombok.Getter;    import lombok.Setter;        import javax.persistence.Entity;    import javax.persistence.Column;    import javax.persistence.Id;    import javax.persistence.GeneratedValue;    import javax.persistence.GenerationType;        @Entity    @Getter    @Setter    public class User {         @Id  @GeneratedValue(strategy = GenerationType.AUTO)     @Column(nullable = false, updatable = false)     private Long id;         private String userName;     private String password;            public User(String userName, String password) {            this.userName = userName;            this.password = password;        }            public User() {    } }  2 - UserRepository.java in the net.devdiaries.wallet.domain package:       package net.devdiaries.wallet.domain;        import org.springframework.data.repository.CrudRepository;    import org.springframework.stereotype.Repository;        import java.util.Optional;        @Repository    public interface UserRepository extends CrudRepository&amp;lt;User, Long&amp;gt; {         Optional&amp;lt;User&amp;gt; findByUserName(String username);  }  Now, we have to create the UserDetailsService implementation. This class (provided by Spring Security) is used for finding and authenticating users. Let‚Äôs create a new package: net.devdiaries.wallet.services with UserDetailsServiceImpl class and inject UserRepository:       package net.devdiaries.wallet.services;        import net.devdiaries.wallet.domain.User;    import net.devdiaries.wallet.domain.UserRepository;    import org.springframework.beans.factory.annotation.Autowired;    import org.springframework.security.core.authority.SimpleGrantedAuthority;    import org.springframework.security.core.userdetails.UserDetails;    import org.springframework.security.core.userdetails.UserDetailsService;    import org.springframework.security.core.userdetails.UsernameNotFoundException;    import org.springframework.stereotype.Service;        import java.util.Arrays;        @Service    public class UserDetailsServiceImpl implements UserDetailsService {         private UserRepository userRepository;      @Autowired     public UserDetailsServiceImpl(UserRepository userRepository) {            this.userRepository = userRepository;        }         @Override  public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {            User user = userRepository.findByUserName(userName)                    .orElseThrow(() -&amp;gt; new UsernameNotFoundException(&quot;User: &quot; + userName + &quot; not found&quot;));            return new org.springframework.security.core.userdetails.User(user.getUserName(), user.getPassword(),                    Arrays.asList(new SimpleGrantedAuthority(&quot;user&quot;)));        }    }      We had to override loadUserByUsername(..) method. This method checks if the user was found or not. Finally, the method returns a Spring Security Userobject with the username, password, and role (we use new SimpleGrantedAuthority(‚Äúuser‚Äù) for this tutorial) of the authenticated user.Configure UserDetailsServiceImpl in the SecurityConfigurationLet‚Äôs return to our SecurityConfiguration class (created above). Now we can complete its configuration:       @Configuration    @EnableWebSecurity    public class SecurityConfiguration extends WebSecurityConfigurerAdapter {         @Autowired  private UserDetailsServiceImpl customUserDetailsService;         @Bean  public PasswordEncoder passwordEncoder() {            return new BCryptPasswordEncoder();        }         @Autowired  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {            auth.userDetailsService(customUserDetailsService).passwordEncoder(new BCryptPasswordEncoder());        }          We have added a configureGlobal(...) method to enable fetching and authorizing users from the database. We‚Äôve also defined PasswordEncoder bean (BCryptPasswordEncoder) which uses the BCrypt hashing algorithm - our password has to be encrypted.Now We can save new users in the CommandLineRunner. Inject UserRepository to the WalletApplication and add users:         package net.devdiaries.wallet;        import net.devdiaries.wallet.domain.Currency;    import net.devdiaries.wallet.domain.CurrencyRepository;    import net.devdiaries.wallet.domain.User;    import net.devdiaries.wallet.domain.UserRepository;    import org.springframework.beans.factory.annotation.Autowired;    import org.springframework.boot.CommandLineRunner;    import org.springframework.boot.SpringApplication;    import org.springframework.boot.autoconfigure.SpringBootApplication;    import org.springframework.context.annotation.Bean;        import java.math.BigDecimal;        @SpringBootApplication    public class WalletApplication {         @Autowired  private CurrencyRepository currencyRepository;         @Autowired  private UserRepository userRepository;         public static void main(String[] args) {         SpringApplication.run(WalletApplication.class, args);        }            @Bean     CommandLineRunner runner() {            return args -&amp;gt; {    //            Save demo data after start      userRepository.save(new User(&quot;admin&quot;, &quot;$2a$04$KNLUwOWHVQZVpXyMBNc7JOzbLiBjb9Tk9bP7KNcPI12ICuvzXQQKG&quot;));         currencyRepository.save(new Currency(&quot;US Dolar&quot;, &quot;USD&quot;, new BigDecimal(100), new BigDecimal(3.92)));             currencyRepository.save(new Currency(&quot;Euro&quot;, &quot;EUR&quot;, new BigDecimal(300), new BigDecimal(4.52)));                };    } }  We have just saved the ‚Äúadmin‚Äù user to our database. $2a$04$KNLUwOWHVQZVpXyMBNc7JOzbLiBjb9Tk9bP7KNcPI12ICuvzXQQKG is BCrypt-encrypted ‚Äúadmin‚Äù password (You can use online encryptors to encrypt another password).Now, if you do GET request to the localhost:8080/currencies you will get a 401 Unauthorized HTTP error. You should authenticate to be able to get currencies (You can do this using the Authorization function in Postman or using curl -u admin).Securing application using JWT tokenOur authentication method is not usable when we are going to use our own frontend app. We are going to use the JSON Web Token (JWT) authentication. JWT defines how to exchange data between web services in a secure way through a JSON object. The information sent can be verified thanks to a digital signature, which is an element of the token.The JWT token is signed using the signature - the HMAC algorithm or with the RSA public/private key. Each JWT token contains three parts separated by dots:  Header: defines the type of the token and the hashing algorithm,  Payload: contains information about the user  Signature: used to verify that JWT has not been changed.You can see the main idea of the JWT in the following image:Creating Authentication FunctionalityLet‚Äôs create a service (in the net.devdiaries.wallet.services package) that will create and validate the JWT token. The service will be called AuthenticationService:       package net.devdiaries.wallet.services;    import io.jsonwebtoken.Jwts;  import io.jsonwebtoken.SignatureAlgorithm;  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  import org.springframework.security.core.Authentication;    import javax.servlet.http.HttpServletRequest;  import javax.servlet.http.HttpServletResponse;  import java.util.Date;    import static java.util.Collections.emptyList;    public class AuthenticationService {      static final long EXPIRATIONTIME = 864_000_00;      static final String SIGNINGKEY = &quot;signingKey&quot;;      static final String BEARER_PREFIX = &quot;Bearer&quot;;        static public void addJWTToken(HttpServletResponse response, String username) {          String JwtToken = Jwts.builder().setSubject(username)                  .setExpiration(new Date(System.currentTimeMillis() + EXPIRATIONTIME))                  .signWith(SignatureAlgorithm.HS512, SIGNINGKEY)                  .compact();          response.addHeader(&quot;Authorization&quot;, BEARER_PREFIX + &quot; &quot; + JwtToken);          response.addHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;Authorization&quot;);      }        static public Authentication getAuthentication(HttpServletRequest request) {          String token = request.getHeader(&quot;Authorization&quot;);          if (token != null) {              String user = Jwts.parser()                      .setSigningKey(SIGNINGKEY)                      .parseClaimsJws(token.replace(BEARER_PREFIX, &quot;&quot;))                      .getBody()                      .getSubject();                if (user != null) {                  return new UsernamePasswordAuthenticationToken(user, null, emptyList());              } else {                  throw new RuntimeException(&quot;Authentication failed&quot;);              }          }          return null;      }  }          In the beginning, we defined several constants. EXPIRATIONTIME defines the expiration time of the token (24 hours), SIGNINGKEY is used to sign the JWT (by verifying the JWT token we have a guarantee that it comes from our application), BEARER_PREFIX is the prefix of Authorization token - we use Bearer schema. The addJWTToken() creates the JWT and adds it to the Authorization header. We also had to add Access-Control-Expose-Headers header due to JS limitations on the frontend side. The getAuthentication() method gets the JWT token from the Authorization header.Next, create a POJO class with user credentials in domain package:package net.devdiaries.wallet.domain;    import lombok.Getter;  import lombok.Setter;    @Getter  @Setter  public class UserCredentials {      private String userName;      private String password;  }We do not have to mark this class with @Entity because this class will only keep credentials for authentication. We do not want to create a new table in the database.Finally, we need to create two filters that will handle requests:1 - Filter for login and authentication - LoginFilter.java which handles all POST request to the `/login‚Äô endpoint:       package net.devdiaries.wallet.services;    import com.fasterxml.jackson.databind.ObjectMapper;  import net.devdiaries.wallet.domain.UserCredentials;  import org.springframework.security.authentication.AuthenticationManager;  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  import org.springframework.security.core.Authentication;  import org.springframework.security.core.AuthenticationException;  import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;  import org.springframework.security.web.util.matcher.AntPathRequestMatcher;    import javax.servlet.FilterChain;  import javax.servlet.http.HttpServletRequest;  import javax.servlet.http.HttpServletResponse;  import java.io.IOException;  import java.util.Collections;      public class LoginFilter extends AbstractAuthenticationProcessingFilter {        public LoginFilter(String url, AuthenticationManager authManager) {          super(new AntPathRequestMatcher(url));          setAuthenticationManager(authManager);      }      @Override    public Authentication attemptAuthentication(              HttpServletRequest req, HttpServletResponse res)              throws AuthenticationException, IOException {          UserCredentials userCredentials = new ObjectMapper()                  .readValue(req.getInputStream(), UserCredentials.class);          return getAuthenticationManager().authenticate(                  new UsernamePasswordAuthenticationToken(                          userCredentials.getUserName(),                          userCredentials.getPassword(),                          Collections.emptyList()                  )          );      }      @Override    protected void successfulAuthentication(              HttpServletRequest req,              HttpServletResponse res, FilterChain chain,              Authentication auth) {          AuthenticationService.addJWTToken(res, auth.getName());      }  }          We extended AbstractAuthenticationProcessingFilter class which requres authenticationManager property in the Spring context (We‚Äôve set it in the SecurityConfiguration class). If the authentication is successful, the successfulAuthentication method will be executed and then the addJWTToken() from AuthenticationService class will add the JWT to the Authorization header.2 - Filter for handling in all other endpoints:       package net.devdiaries.wallet.services;    import org.springframework.security.core.Authentication;  import org.springframework.security.core.context.SecurityContextHolder;  import org.springframework.web.filter.GenericFilterBean;    import javax.servlet.FilterChain;  import javax.servlet.ServletException;  import javax.servlet.ServletRequest;  import javax.servlet.ServletResponse;  import javax.servlet.http.HttpServletRequest;  import java.io.IOException;    public class AuthenticationFilter extends GenericFilterBean {      @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)              throws IOException, ServletException {          Authentication authentication = AuthenticationService.getAuthentication((HttpServletRequest)request);            SecurityContextHolder.getContext().setAuthentication(authentication);          filterChain.doFilter(request, response);      }  }        This filter extends GenericFilterBean and gets a token from the request header.Finally, we have to update SecurityConfiguration class by overriding the configure() method. The following source code shows the SecurityConfiguration final code:       package net.devdiaries.wallet.configuration;    import net.devdiaries.wallet.services.AuthenticationFilter;  import net.devdiaries.wallet.services.LoginFilter;  import net.devdiaries.wallet.services.UserDetailsServiceImpl;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;  import org.springframework.http.HttpMethod;  import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;  import org.springframework.security.config.annotation.web.builders.HttpSecurity;  import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  import org.springframework.security.crypto.password.PasswordEncoder;  import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  import org.springframework.web.cors.CorsConfiguration;  import org.springframework.web.cors.CorsConfigurationSource;  import org.springframework.web.cors.UrlBasedCorsConfigurationSource;    import java.util.Arrays;    @Configuration  @EnableWebSecurity  public class SecurityConfiguration extends WebSecurityConfigurerAdapter {      @Autowired    private UserDetailsServiceImpl customUserDetailsService;      @Bean    public PasswordEncoder passwordEncoder() {          return new BCryptPasswordEncoder();      }        @Override    protected void configure(HttpSecurity http) throws Exception {          http.csrf().disable().cors().and().authorizeRequests()                  .antMatchers(HttpMethod.POST, &quot;/login&quot;).permitAll()                  .anyRequest().authenticated()                  .and()                  .addFilterBefore(new LoginFilter(&quot;/login&quot;, authenticationManager()),                          UsernamePasswordAuthenticationFilter.class)                  .addFilterBefore(new AuthenticationFilter(),                          UsernamePasswordAuthenticationFilter.class);      }      @Bean    CorsConfigurationSource corsConfigurationSource() {          UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();          CorsConfiguration config = new CorsConfiguration();          config.setAllowedOrigins(Arrays.asList(&quot;*&quot;));          config.setAllowedMethods(Arrays.asList(&quot;*&quot;));          config.setAllowedHeaders(Arrays.asList(&quot;*&quot;));          config.setAllowCredentials(true);          config.applyPermitDefaultValues();            source.registerCorsConfiguration(&quot;/**&quot;, config);          return source;      }      @Autowired    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {          auth.userDetailsService(customUserDetailsService).passwordEncoder(new BCryptPasswordEncoder());      }  }          We defined that requests for all requests (except /login endpoint) requires authentication. We also added CORS filter. This is needed for frontend which is sending request from the other origin.SummaryRun the application and call the /login endpoint with the POST HTTP method (using a postman or curl). In body add username and password which are in the database:As you can see, we got JWT in response (Authorization header - at the bottom of the picture). Copy this token and add it to the Authorization header in the request for localhost:8080/currencies. In response, you will receive all the currencies.Congratulations, the backend is almost ready! In the next post, we will start to create a frontend in React.",
      "url"      : "/blog/Spring-Boot-2-PostgreSQL-JWT-React-Part-3/",
      "image"    : "/images/spring-react-currency-walet/header-image-part3.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "spring, java, react",
      "title"    : "Spring Boot 2 + PostgreSQL + JWT + React - Full Stack Web Development - Part 2 RESTful Web Service",
      "description": "Our application works quite well, but we would like to use the REST principle...",
      "content": "Our application works quite well, but we would like to use the REST principles and manage data via HTTP requests.  In Spring Boot, HTTP requests are handled by controller classes.In the previous post, we have created an application that automatically creates a database and adds some data to it. Let‚Äôs add controllers to it!REST basicsREST (Representational State Transfer) is an architectural style for designing distributed systems. It‚Äôs not a standard, but it defines a set of constraints such as being stateless or having a client/server relationship. The six constraints defined by Roy Fielding (REST creator):  Stateless: The server doesn‚Äôt hold any information about users,  Cacheable: Many users request the same resources. It is useful to cache responses,  Uniform interface between components: This simplifies the architecture, as all components follow the same rules to speak to one another,  Layered system: individual components cannot see beyond the immediate layer with which they are interacting,  Client-server architecture: the client and the server both have a different set of concerns. The server does not send any information without a request from the client,  Code on demand: code may be downloaded to extend client functionality. This is an optional constraint.RESTful Spring Boot serviceIn Spring boot all requests are handled by controller classes. We have to create our own controller class. To do this, let‚Äôs first create the java package for our controller (I created net.devdiaries.wallet.controllers package). Next, create the controller class: CurrenciesController.java.Now, add the @RestController annotation before the class definition.  @RestController is used to mark classes as Spring MVC Controller. Our controller class looks like this:         package net.devdiaries.wallet.controllers;        import org.springframework.web.bind.annotation.RestController;        @RestController    public class CurrencyController {            }  To be able to return currencies from the database, we have to inject CurrencyRepository created in previous post.We will also add a method with the @RequestMapping annotation, which will fetch all currencies from CurrencyRepository.  @RequestMapping maps the URL address and/or HTTP method to the controller. Now our code looks like this:           package net.devdiaries.wallet.controllers;        import net.devdiaries.wallet.domain.Currency;    import net.devdiaries.wallet.domain.CurrencyRepository;    import org.springframework.beans.factory.annotation.Autowired;    import org.springframework.web.bind.annotation.*;            @RestController    public class CurrencyController {         private final CurrencyRepository currencyRepository;         @Autowired     public CurrencyController(CurrencyRepository currencyRepository) {            this.currencyRepository = currencyRepository;        }         @GetMapping(&quot;/currencies&quot;)     public Iterable&amp;lt;Currency&amp;gt; getCurrencies() {            return currencyRepository.findAll();        }    }      We are ready to run the application. After run navigates to localhost:8080/currencies. We can see that application get all the currencies from the database and return it in JSON format:We must add a few more methods that we will need in our Wallet application.1 - addCurrency() method marked by @PostMapping annotation:            @PostMapping(&quot;/currencies&quot;)    void addCurrency(@RequestBody Currency currency) {        currencyRepository.save(currency);    }  Annotation @PostMapping ( &quot;/currencies&quot;) maps the given path to the appropriate method that will handle the HTTP request (POST). @RequestBody annotation maps the HttpRequest body to a transfer or domain object (Currency object).2 - updateCurrency() method which will be used to update the currency status:        @PutMapping(&quot;/currencies&quot;)    void updateCurrency(@RequestBody Currency currency) {        currencyRepository.save(currency);    }      3 - deleteCurrency() method for removing Currency objects from database:            @DeleteMapping(&quot;/currencies/{id}&quot;)    void deleteCurrency(@PathVariable Long id) {        currencyRepository.deleteById(id);    }  In deleteCurrency() we used the @PathVariable annotation that will retrieve the currency id from the URI.The following source code shows the controller final code:   package net.devdiaries.wallet.controllers;        import net.devdiaries.wallet.domain.Currency;    import net.devdiaries.wallet.domain.CurrencyRepository;    import org.springframework.beans.factory.annotation.Autowired;    import org.springframework.web.bind.annotation.RestController;    import org.springframework.web.bind.annotation.GetMapping;    import org.springframework.web.bind.annotation.DeleteMapping;    import org.springframework.web.bind.annotation.PostMapping;    import org.springframework.web.bind.annotation.PutMapping;    import org.springframework.web.bind.annotation.PathVariable;    import org.springframework.web.bind.annotation.RequestBody;            @RestController    public class CurrencyController {         private final CurrencyRepository currencyRepository;         @Autowired     public CurrencyController(CurrencyRepository currencyRepository) {            this.currencyRepository = currencyRepository;        }         @GetMapping(&quot;/currencies&quot;)     public Iterable&amp;lt;Currency&amp;gt; getCurrencies() {            return currencyRepository.findAll();        }            @DeleteMapping(&quot;/currencies/{id}&quot;)        void deleteCurrency(@PathVariable Long id) {            currencyRepository.deleteById(id);        }            @PostMapping(&quot;/currencies&quot;)        void addCurrency(@RequestBody Currency currency) {            currencyRepository.save(currency);        }            @PutMapping(&quot;/currencies&quot;)        void updateCurrency(@RequestBody Currency currency) {            currencyRepository.save(currency);    } }           SummaryCongratulations! That‚Äôs all. We have created a controller with which the frontend of our application will communicate via REST. In the next post, we will take care of securing the backend of our application.I invite you to read the next part.",
      "url"      : "/blog/Spring-Boot-2-PostgreSQL-JWT-React-Part-2/",
      "image"    : "/images/spring-react-currency-walet/header-image-part2.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "spring, java, react",
      "title"    : "Spring Boot 2 + PostgreSQL + JWT + React - Full Stack Web Development - Part 1 Spring Initialzr and JPA",
      "description": "In this series, we will create a modern web application using Spring Boot 2.1...",
      "content": "In this series, we will create a modern web application using Spring Boot 2.1.5 and React. We will start from the backend creating an API in Spring Boot and using the PostgreSQL database. The frontend will be created using the React.The application that we will develop will be a currency portfolio. We will be able to add, edit and delete currencies from the database. In addition, we will secure our application using the JWT token, so that we only have access to our data.Requirements  Java knowledge  Basic Spring Boot knowledge  Basic JavaScript knowledge  Basic Maven knowledge  Basic knowledge of SQL databasesSetting Up the backend environmentWe are going to create and run Spring Boot project. To do this you must have Java SDK installed (version 8 or higher) any IDE (I will use Intellij).Creating the project with Spring InitializrWe will create the Spring Boot project with Spring Initializr. It is a web tool that‚Äôs used to create Spring projects. You can use web-based initializr (https://start.spring.io/) or provided by IDE (in the case of Intellij).We will generate a Maven project with the latest Spring Boot version (2.1.5). In the Dependencies section, we will select dependencies that are needed in our project. Please start with following dependencies:  Web: Spring Web Starter  JPA: Spring Data JPA  H2 Database  PostgreSQL Driver  Lombok  Spring Boot DevToolsThe DevTools provides facilities for developers (e.g. automatic restart after changes). Development is much faster because the application is automatically restarted after new changes have been detected. After all, your pom.xml should look something like this:          &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;    &amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;        &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;        &amp;lt;parent&amp;gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;            &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;            &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;            &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;      &amp;lt;/parent&amp;gt;        &amp;lt;groupId&amp;gt;net.devdiaries&amp;lt;/groupId&amp;gt;        &amp;lt;artifactId&amp;gt;wallet&amp;lt;/artifactId&amp;gt;        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;        &amp;lt;name&amp;gt;wallet&amp;lt;/name&amp;gt;        &amp;lt;description&amp;gt;Application for devdiaries.net&amp;lt;/description&amp;gt;         &amp;lt;properties&amp;gt;        &amp;lt;java.version&amp;gt;12&amp;lt;/java.version&amp;gt;        &amp;lt;/properties&amp;gt;            &amp;lt;dependencies&amp;gt;            &amp;lt;dependency&amp;gt;                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;            &amp;lt;/dependency&amp;gt;                &amp;lt;dependency&amp;gt;                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;                &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;                &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;            &amp;lt;/dependency&amp;gt;            &amp;lt;dependency&amp;gt;                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;                &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;            &amp;lt;/dependency&amp;gt;            &amp;lt;dependency&amp;gt;                &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;                &amp;lt;version&amp;gt;1.4.199&amp;lt;/version&amp;gt;                &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;        &amp;lt;/dependency&amp;gt;            &amp;lt;dependency&amp;gt;                &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;                &amp;lt;version&amp;gt;1.18.8&amp;lt;/version&amp;gt;                &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;            &amp;lt;/dependency&amp;gt;            &amp;lt;dependency&amp;gt;                &amp;lt;groupId&amp;gt;org.postgresql&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;postgresql&amp;lt;/artifactId&amp;gt;                &amp;lt;version&amp;gt;42.2.5&amp;lt;/version&amp;gt;            &amp;lt;/dependency&amp;gt;            &amp;lt;dependency&amp;gt;                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;                &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;            &amp;lt;/dependency&amp;gt;        &amp;lt;/dependencies&amp;gt;            &amp;lt;build&amp;gt;            &amp;lt;plugins&amp;gt;                &amp;lt;plugin&amp;gt;                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                    &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;                &amp;lt;/plugin&amp;gt;            &amp;lt;/plugins&amp;gt;        &amp;lt;/build&amp;gt;     &amp;lt;/project&amp;gt;  If you do not want to generate a project in the initializr - you can use my pom.xml.Initializer has generated a directory structure with the main application class:WalletApplication.java:          @SpringBootApplication  public class WalletApplication {     public static void main(String[] args) { SpringApplication.run(WalletApplication.class, args); }  }  In addition to the usual class with the main() method, you probably noticed the @SpringBootApplication annotation. It is a combination of multiple annotations. The most important of them are:  @EnableAutoConfiguration - tells Spring Boot how you will want to configure Spring, based on the jar dependencies that you have added to the pom.xml.  @ComponentScan  - tells Spring to look for other components, configurations, and services in the specified package.  @Configure - Defines the class that can be used as a source of bean definitions.Spring Boot JPA ConfigurationNow, we will create a database by using JPA. Firstly, we will use H2 in-memory SQL database (good for fast development, we do not have to run any databases - Spring will do it for us, storing data in memory).JPA and HibernateJPA (Java Persistent API) provides object-relational mapping for Java applications. In the case of databases, we are talking about entities and therefore the most important annotation in the case of JPA is @Entity. The @Entity class presents the structure of a database table and the fields of an @Entity class present the columns. Hibernate is the most popular JPA implementation and is used in Spring Boot by default.Creating the entity classes in Spring BootEntity classes use the standard JavaBean naming convention and have getters/setters. All fields have private visibility.  JPA creates tables with the names of the classes. If you want to use another name for the table, you should use @Table annotationLet‚Äôs create a package for our Entity class and classes related to retrieving records from the database (repositories). We will use domain name: net.devdiaries.wallet.domain.  Next, we create entity classes - Our database will contain currency portfolios. My Currency.java class:          package net.devdiaries.wallet.domain;        import lombok.Getter;    import lombok.Setter;        import javax.persistence.*;    import java.math.BigDecimal;        @Entity    @Getter    @Setter    public class Currency {         public Currency(String name, String code, BigDecimal amount, BigDecimal rate) {        this.name = name;            this.code = code;            this.amount = amount;            this.rate = rate;        }            @Id        @GeneratedValue(strategy = GenerationType.AUTO)        private long id;            private String name;            private String code;            private BigDecimal amount;            private BigDecimal rate;       }  The @Id annotation defines the primary key.  The @GeneratedValue tells that the ID is automatically generated by the database. We use AUTO strategy. It means that the JPA provider selects the best strategy for a particular database. Instead of creating getters/setters methods, we used Lombok (@Getter, @Setter), which will create it for us during compilation.We already have a class that will create a table with columns in the database. Now it‚Äôs time to create Repository class - which provides functionality for Creating/Removing/Updating/Deleting data from the database. We will start from repository for Currency class:  package net.devdiaries.wallet.domain;        import org.springframework.data.repository.CrudRepository;        public interface CurrencyRepository extends CrudRepository&amp;lt;Currency, Long&amp;gt; {    }          CurrencyRepository extends the CrudRepository&amp;lt;Currency, Long&amp;gt;. It defines that this repository is for the Currency entity class and the type of Id is long.CrudRepository provides multiple CRUD methods. Most important of them:            Method      Description                  long count()      returns number of entities              &amp;lt; S extends T &amp;gt; save(S entity)      saves an entity              Iterable findAll()      returns all records of provided type              Optional findById(ID id)      returns one record for given ID              void delete(T entity)      deletes entity      Let`s check that everything is done correctly:1 - Add settings to application.properties    spring.jpa.show-sql=true    spring.h2.console.enabled=true    spring.h2.console.path=/h2-console        It enables the H2 console and logs all Hibernate queries.2 - Run WalletApplication application3 - Go to localhost:8080/h2-console and use jdbc:h2:mem:testdb as JDBC URL:4 - Use SELECT * FROM CURRENCY  query and click Run button. H2 console should return no rows:Use CommandLineRunner to inject demo dataNow we will add some demo data to the H2 database. For that, we will use the CommandLineRunner class. This class provides the functionality to run specific pieces of code when the application is fully started. Let‚Äôs use it in the main application class:  @SpringBootApplication    public class WalletApplication {         @Autowired private CurrencyRepository currencyRepository;             public static void main(String[] args) {            SpringApplication.run(WalletApplication.class, args);        }            @Bean     CommandLineRunner runner() {            return args -&amp;gt; {    //            Save demo data after start                currencyRepository.save(new Currency(&quot;US Dolar&quot;, &quot;USD&quot;, new BigDecimal(100), new BigDecimal(3.92)));                currencyRepository.save(new Currency(&quot;Euro&quot;, &quot;EUR&quot;, new BigDecimal(300), new BigDecimal(4.52)));            };        }    }          We injected CurrencyRepository using @Autowired which enables dependency injection (described in https://www.devdiaries.net/blog/Spring-Design-Patterns-Dependency-Injection/ post).Next, we used the save() method from CrudRepository to save objects in the database.Now repeat the 4. point described above. You will see that new records have appeared in the database:Hibernate logs:        Hibernate: call next value for hibernate_sequence  Hibernate: insert into currency (amount, code, name, rate, id) values (?, ?, ?, ?, ?)  Hibernate: call next value for hibernate_sequence  Hibernate: insert into currency (amount, code, name, rate, id) values (?, ?, ?, ?, ?)    SummaryThe first part was done! In the next post, we will create a RESTful service. We will add the controller and use Spring MVC.The second part of the tutorial is available at PART 2.",
      "url"      : "/blog/Spring-Boot-2-PostgreSQL-JWT-React-Part-1/",
      "image"    : "/images/spring-react-currency-walet/header-image-part1.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "Spring Framework, Java, Design patterns",
      "title"    : "Design Patterns used in Spring Framework Part 2 - Creational Patterns (Factory, Builder, Singleton, Prototype).",
      "description": "Creational design patterns deal with object creation mechanisms, trying to cr...",
      "content": "Creational design patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. In this article, I will describe the most popular patterns in this category and how Spring uses them!The Factory patternSpring, in itself, is already an example implementation of the Factory pattern. The pattern is used throughout the entire framework. One of the primary places it‚Äôs used is the BeanFactory class.Intent  Factory pattern allows construction of similar classes of different types using a factory method  Method call creates the object for you  Created objects are instances from classes that share an interface or subclassProblem Solution  Thanks to Factory Design Pattern you do not have to worry about class construction in more than one place.  It allows you to leverage the interface for repetitive operations.  Copy-paste bugs are less likely.Structure of the Factory PatternFirstly, you have to create common interface that you are going to use in objects factory. Then, you need to create a class that creates instances of your inteface. In that class, you have to implement a method that servers concrete classes that you will then implement from the interface itself. So, again, we have a class that has a method that creates instances of the interface when under the coverage that it‚Äôs actually creating instances in the concrete class.Abstract Factory PatternAbstract Factory Pattern is a pattern very similar to the Factory Pattern. You can say that it is Factory of factories. In a nutshell, there are two main differences between the Factory Pattern and Abstract Factory:  Abstract Factory design pattern creates Factory  Factory design pattern creates Products  public abstract class AbstractFactory {      public abstract Product1Base CreateProduct1();      public abstract Product2Base CreateProduct2();  }  class ConcreteFactory1 extends AbstractFactory{        @Override    public Product1Base CreateProduct1() {          return new ConcreteProduct1();      }        @Override    public Product2Base CreateProduct2() {          return new ConcreteProduct2();      }  }    class ConcreteFactory2 extends AbstractFactory{        @Override    public Product1Base CreateProduct1() {          return new ConcreteAnotherProduct1();      }        @Override    public Product2Base CreateProduct2() {          return new ConcreteAnotherProduct2();      }  }  The AbstractFactory class is responsible for creating several different types (in contrast to Factory Pattern). As you can see in the above example, each of the factories can be associated with different objects within the same group (in this case - products).Factory Pattern implementation in SpringLet`s take a look at above interface:    public interface Animal {      void setName(String name);      String getName();      String getType();      void makeASound();  }Animal interface has several methods that are common to all animals (each animal has a type and name). So, now you need to create a new class: AnimalFactory  @Component  public class AnimalFactory {      public Animal createAnimal(String type) {          switch (type) {              case &quot;bird&quot;:                  return new Bird();              case &quot;cat&quot;:                  return new Cat();              default:                  throw new UnsupportedOperationException(&quot;Unsupported animal type!&quot;);          }        }  }I added @Component annotation because I want the Spring to manage this factory. There is one method (factory method) which returns an Animal - createAnimal.  It is a very simple factory that supports only two types of animals (cat, bird). If another type is provided, an exception will be thrown.Let‚Äôs create Spring controller - FactoryController:  @RestController  @RequestMapping(&quot;/&quot;)  public class FactoryController {        private AnimalFactory factory;        @Autowired    public FactoryController(AnimalFactory factory) {          this.factory = factory;      }        @PostMapping(&quot;addAminal/{type}/{name}&quot;)      public Animal addAnimal(@PathVariable String type, @PathVariable String name) {          Animal animal = this.factory.createAnimal(type);          animal.setName(name);          animal.makeASound();          return animal;      }  }I added one @PostMapping method, which we will pass through the @PathVariable type and name of the animal. In response, we will get the new animal object created by the factory.Let‚Äôs test it using a postman:Application logs:As you can see, we have just created a new object - a bird using our factory.Factory Pattern popular use cases in Spring FrameworkThe Spring framework uses the factory design pattern for the creation of the objects by using two approaches:  Spring BeanFactory Container (e.g org.springframework.beans.factory.BeanFactory) - It is the simplest container  in the Spring framework which provides the basic support for DI  Spring ApplicationContext Container (e.g [org.springframework.context.ApplicationContext]) - t is another container present in spring container which adds extra enterprise-specific functionality such as publishing application events to the attentive event listeners or loading messages from a properties file.As you can see, entire Spring is already an example implementation of the Factory pattern (any Spring application‚Äôs application context is just a giant Factory)The Builder patternAnother common creational pattern is the Builder pattern.  The popular use of Builder in the Spring is ResultAction. This class is part of the MockMcv - used for testing web applications.Intent  Each method return the object reference it`s called from.  There is build() method which returns a fully contstructed object (based on all the intermediate calls).Problem Solution  Improves the readability of the code when object creation has many parameters.  Useful when some or all paramaters are optional.Structure of the Builder PatternFirstly, you need to define a base class with all args constructor. Then, you have to create a Builder class with attributes and setters for each argument of the base class. Each setter should return the builder. Then, need to create a build() methid that will construct and return object of base class.Builder Pattern implementation in SpringI started my implementation with a simple Java class - Employee.java:  public class Employee {      private String firstName;      private String lastName;      private String employeeId;      private String email;        public Employee(String firstName, String lastName, String employeeId, String email) {          this.firstName = firstName;          this.lastName = lastName;          this.employeeId = employeeId;          this.email = email;      }        public Employee() {      }        public String getFirstName() {          return firstName;      }        public String getLastName() {          return lastName;      }        public String getEmployeeId() {          return employeeId;      }          public String getEmail() {          return email;      }  }There are a couple attributes, contructor and auto-generated getters. It‚Äôs time for implementing builder pattern! To do this, create the EmployeeBuilder class with the same fields as the Employee class. Generate setters - one for each of our fields. If you generate setters by IDE, you must remember to change the type returned by setter (void) to EmployeeBuilder.  public class EmployeeBuilder {      private String firstName;      private String lastName;      private String employeeId;      private String email;        // Each setter returns EmployeBuilder object.    public EmployeeBuilder setFirstName(String firstName) {          this.firstName = firstName;          return this;      }        public EmployeeBuilder setLastName(String lastName) {          this.lastName = lastName;          return this;      }        public EmployeeBuilder setEmployeeId(String employeeId) {          this.employeeId = employeeId;          return this;      }        public EmployeeBuilder setEmail(String email) {          this.email = email;          return this;      }        public Employee buildEmployee() {          return new Employee(firstName,lastName, employeeId, email);      }  }At the end I use the public Employee buildEmployee() method that creates the employee. The advantage of this solution is that if any of our fields are null, null will be populated. We don‚Äôt really have to think about where the nulls go. Let‚Äôs take a look at action. I created BuilderController Spring controller which has two endpoints. The first creates an employee with all fields, the second creates an employee without an email:  @RestController  @RequestMapping(&quot;/builder&quot;)  public class BuilderController {        @GetMapping(&quot;employee1&quot;)      public Employee getEmployee1() {          return new EmployeeBuilder()                  .setEmployeeId(&quot;1234&quot;)                  .setEmail(&quot;test@test.com&quot;)                  .setFirstName(&quot;John&quot;)                  .setLastName(&quot;smith&quot;)                  .buildEmployee();      }        @GetMapping(&quot;employee2&quot;)      public Employee getEmployee2() {          return new EmployeeBuilder()                  .setEmployeeId(&quot;4321&quot;)                  .setFirstName(&quot;Jeff&quot;)                  .setLastName(&quot;Freeman&quot;)                  .buildEmployee();      }  }As you probably expect, the GET request on the first edpoint returns: The second endpoint returns the employee with a null as an email:The Singleton patternSingleton is a pattern used by every Java developer who uses Spring. Every bean is by default a singleton. Its purpose is to provide the possibility of creating only one object of a given class and providing global access to it.Intent  There is an only private constructor.  Class stores reference to the instance of itself.  There is getInstance() method which returns a reference of singleton class instance or constructs new object if not constructed.In Singleton pattern, Java new Class is never called on the class except getInstance case. You should wrap this method with some locking functionality to ensure multi-thread safety.Problem SolutionSingleton can be used in cases:  Object creation is expensive.  The class that stores the application configuration. From anywhere in the system, we can modify it and we want the changes to be visible from anywhere. At the same time, we can not allow different versions of configurations to be maintained in the system.  You need to store static state for multiple parts of the application.  You need to control who has access to an object (concurrency controlling).Structure of the Singleton PatternThere are many ways to implement a singleton, but all can be reduced to three main points:  First you have to create a private constructor in your Singleton class  Then, create an instance handle which is stored in the class  Create static getInstance() method that uses a synchronized block on the object to reduce the thread safety risk.Singleton Pattern exemplary implementation in SpringIn the following example, we will implement our own Singleton. Then we will prove that the Spring components are singletons by default. Let‚Äôs start with creating a couple of classes. The first one we are going to create is Singleton.java class which will be a traditional singleton (described in the previous point):public class Singleton {      private static Singleton instance;        private Singleton(){}        public static Singleton getInstance() {          if(null == instance){              synchronized (Singleton.class){                  if(null==instance) {                      instance = new Singleton();                  }              }          }          return instance;      }  }Now, create simple Spring @Component class without any logic:@Component  public class SpringSingleton {  }Next, let‚Äôs test whether our singletons ensure that only one object is created. I used the JUnit test (generated automatically when creating a Spring Boot project in Spring Initializer):@RunWith(SpringRunner.class)  @SpringBootTest  public class SpringDesignPatternsApplicationTests {        @Autowired    SpringSingleton springSingleton1;        @Autowired    SpringSingleton springSingleton2;        @Test    public void singletonObjectsShouldBeEquals() {            Singleton singleton1 = Singleton.getInstance();          Singleton singleton2 = Singleton.getInstance();    //      Checking if the Singleton objects are definitely one, the same object    Assert.assertSame(singleton1, singleton2);    //      Checking if the spring components are definitely singletons    Assert.assertSame(springSingleton1, springSingleton2);      }  }assertSame() method checks if arguments are same objects. Test result: passed - everything was the same. That`s how you can write traditional singletons or singletons in Spring.Singleton Pattern vs Spring SingletonsThere is one more thing you should know. As I wrote - all Spring beans are singletons by default. However, these are not the same singletons as the traditional singletons. The traditional Singleton pattern assumes that there is only one instance of a given class at the space managed by Java classloader. In Spring, there is only one instance of Bean for each given context (_org.springframework.context.ApplicationContext) instance. So, if you have more then one context, all managed by the same Java classloader, you will probably have more than one instance of a bean.The Prototype patternThe prototype is a pattern whose purpose is to copy objects from the parent object. In the prototype pattern, a new object is created by cloning an existing object. In Java, the clone() method is an implementation of this design pattern.Intent  Instance is cloned at runtime to give new instances that have the same state  In Java It‚Äôs done with the Cloneable interface/Problem SolutionThe prototype can be used in cases:  You have to create a lot of instances of the same or similar objects, and cloning is more efficient than creating instances of objects with the new Java keyword.  Useful with objects that must be thread safe and need to store state (e.g shopping carts - where you want to have the same behavior but the individual items in the cart are different)Structure of the Prototype Pattern  Create an abstract base class that implements Cloneable.  Extend abstract class in prototype instances.  Override the clone() method in those prototype instances - add the class specific behavior.PrototypePattern implementation in SpringI will not implement the traditional Java prototype. However, I will show you how to create a prototype bean in Spring. I created one dumb class: SpringPrototype.java  public class SpringPrototype {  }In the main application class in Spring, I defined defined a new prototype bean by setting @Scope to prototype:  @Bean  @Scope(&quot;prototype&quot;)  public SpringPrototype prototype(){      return new SpringPrototype();  }JUnit test:    @Autowired  SpringPrototype prototype1;    @Autowired  SpringPrototype prototype2;    @Test  public void prototypeObjectsShouldNotBeEquals() {      Assert.assertNotSame(prototype1, prototype2);  }I injected two instances of the SpringPrototype class with @Autowired. Just like in the Singleton example - I used the static method from Assert to check that the created instances are not the same. My test is green. It‚Äôs proof that there are two different instances of the same object.ConclusionI hope you liked the post. We‚Äôve got to know the most important creational patterns used in Spring. In the next post, we will learn about structural patterns in Spring Framework!The source code from the post is available on my Github repo.",
      "url"      : "/blog/Spring-Design-Patterns-Creational-Patterns/",
      "image"    : "/images/spring-design-patterns-creational.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "Spring Framework, Java, Design patterns",
      "title"    : "Design Patterns used in Spring Framework Part 1 (Inversion of Control, Dependency Injection).",
      "description": "A lot of ground will be covered in these posts, but it will all center around...",
      "content": "A lot of ground will be covered in these posts, but it will all center around Spring Framework.  I will show you the most important design patterns used in Spring, thanks to which you will understand this framework better.Requirements:  Java knowledge  Basic Spring knowledge  Object-Oriented ProgrammingWhat are Design Patterns?Design patterns are solutions to common problems. You can say that Design Patterns are guidelines on how to tackle problems in certain situations.  There are three types of patterns:Creational Design Patterns  Creational patterns are focused on how to instantiate an object or group of related objects.Structural Design Patterns  Structural patterns are mostly concerned with object composition or in other words how the entities can use each other.Behavioral Design Patterns  Behavioral Patterns are concerned with providing solutions regarding object interaction - how they communicate, how are some dependent on others.Inversion of ControlInversion of Control is one of the most important patterns that is used by Spring. This is the main principle of Spring. The main advantages of IoC are:  Decreases coupling  Improves testability  Greater modularity of a programHow it works? The control of application objects is transferred to a container or framework. A central container constructs and manages all objects references. When other components within the application need an object - IoC container hands it to them.    How it works in Spring Framework? In Spring, the IoC container manages all of the application dependencies. Instead of writing ‚Äúnew Class()‚Äù on your code, the object is created by someone else. This ‚Äòsomeone else‚Äô is referred to as the IoC Container.     In addition to creating new objects, Spring IoC container manages their entire life cycle. That includes creating objects, destroying them and invoking certain methods of the object (callbacks).  So, what are the benefits of Spring IoC? Firstly, it reduces noise in the code (Imagine creating a JDBC connection object in dozens of classes). It also reduces object coupling, because you are handed a dependency into your object, you are not as tightly coupled to it (you actually don`t need to know how it is constructed).Dependency Injection  Dependency injection is a software design pattern that implements inversion of control for resolving dependencies.Let‚Äôs start with a simple example:      interface Screen {          void print(String text);      }            class MainScreen implements Screen {         @Override    public void print(String text) {              System.out.println(text);      } }      }            class PrintOnScreen {          private final Screen screen = new MainScreen();          void showMessage(String text) {              screen.print(&quot;Text:&quot; + text);          }      }            public static void printHelloWorldMessage() {          PrintOnScreen printOnScreen = new PrintOnScreen();          printOnScreen.showMessage(&quot;Hello World&quot;);      }      Writing a unit test for the PrintOnScreen class is non-trivial. Additionally, in the PrintOnScreen class there is initialized the printer field with a specific implementation. If we would like to change the implementation of the Screen interface, it will be necessary to modify the code of the MainScreen class. We can get rid of these disadvantages using the DI approach. We just need to modify the MainScreen class to accept the Screen  , for example - injected by the constructor:      class PrintOnScreen {          private final Screen screen = new Screen();          PrintOnScreen(Screen screen) {          this.screen = screen;          }          void showMessage(String text) {              screen.print(&quot;Text:&quot; + text);          }      }            public static void printHelloWorldMessage() {      Screen screen = new MainScreen();          PrintOnScreen printOnScreen = new PrintOnScreen(screen);          printOnScreen.showMessage(&quot;Hello World&quot;);      }      This implementation of the PrintOnScreen class will be easier to test. The test in Mockito might look like this:      class PrintOnScreenTest {          @Test          void shouldPrintHelloWorld() {              // given              Screen screen= mock(Screen.class);              PrintOnScreen printOnScreen= new PrintOnScreen(screen);              String text= &quot;Hello World&quot;;              // when              printOnScreen.showMessage(text);              // then              verify(screen).print(argThat(arg -&amp;gt; arg.contains(&quot;Hello World&quot;)));          }      }      By using DI, the PrintOnScreen class has become easier to test, but initialization is more complicated. Fortunately, Spring Framework allows us to use the benefits of DI in an easier way.Dependency Injection in Spring FrameworkOne way to create a Spring bean is to add the @Component annotation to the class that you want to become a bean. The container will create an instance of this class and inject the required dependencies into it.   There are 3 ways to inject dependencies:  Constructor Dependency Injection:      class DependencyInjectionExample {         private final MainScreen mainScreen;         DependencyInjectionExample(MainScreen mainScreen) {      this.mainScreen = mainScreen;     }         public void printMessage() {      mainScreen.showMessage(&quot;Heeeellooo !&quot;);    }    }      Setter Dependency Injection:      class PrintOnScreen {                private Screen screen;                @Autowired      void seetScreen(Screen screen) {              this.screen= screen;      }      }        Field Dependency Injection:      class PrintOnScreen {           @Autowired      private Screen screen;      }      Which way of dependency injection is the best?Injection through the field seems to be the most convenient, but this approach has several disadvantages:  You can not add a final modifier to such a field, which makes our class mutable.  This makes it difficult to initialize dependencies in tests.  If we use injecting by the constructor and our application will have a cyclic relationship between the beans, we‚Äôll get an exception just after starting the application. If injected through the field, the exception will not fly and the application will work.Spring developers recommend injecting by the constructor.What if more than one bean implements the same interface?Sometimes several classes - beanes implements the same interface:      @Bean  Screen messageScreen() {      return message -&amp;gt; System.out.println(message);  }    @Bean  Screen warnScreen() {      return message -&amp;gt; System.out.println(message);  }    Then we need to indicate the implementation that is to be injected. We have several options:  Using the bean name as the name of the method parameter      @Bean(&quot;messageScreenBean&quot;)  Screen messageScreen() {  If we do not give the name of the bean in the annotation parameter, it will be the name of the method by default.  @Qualifier annotation      @Qualifier(&quot;messageScreen&quot;)  @Bean  Screen messageScreen()         @Bean  MessagePrinter printer(@Qualifier(&quot;messageScreen&quot;) Screen screen)    We can mark one of the beans with @Primary annotation. If there is no qualifier for injection, this implementation will be selected by default.SummaryIn this post, I demonstrated basic examples of Dependency Injection in the Spring Framework. I hope you can see how simple Spring makes Dependency Injection.If you liked it, I invite you to read the next part in which I described the most popular creational design patterns: Design Patterns used in Spring Framework Part 2 - Creational Patterns.",
      "url"      : "/blog/Spring-Design-Patterns-Dependency-Injection/",
      "image"    : "/images/spring-design-patterns-dependency-injection.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "Jekyll, SSL, Github, Google",
      "title"    : "How to set up custom domain for Github Pages with HTTPS",
      "description": "The purpose of this guide is to add a custom domain pointing to the website o...",
      "content": "The purpose of this guide is to add a custom domain pointing to the website on Github Pages. The domain will use an SSL certificate. Finally, we‚Äôll add the domain to Google. The whole operation takes only a few minutes and can be done in a few steps.Requirements:  Purchased domain (I bought it on porkbun.com. You can buy domain anywhere, for example on Google Domains)  A github pages repository, e.g. https://github.com/username/username.github.ioAdd custom domain to Github Pages settingsGo to your github repository settings page:Add you custom domain name (www.domain) at Settings -&amp;gt; GitHub Pages -&amp;gt; Custom domain:Point your custom domain to your Github Page`s websiteIf you also use Porkbun, you can easily point the domain to your GitHub pages using the guide: Connect domain to Github PagesIf you use Google Domains, select your domain in the Admin panel. Then go to DNS&amp;gt; Custom resource records and add the DNS records:  185.199.111.153  185.199.110.153  185.199.109.153  185.199.108.153  Add the CNAME record: name - www, type - CNAME, answer/value - yoursite.github.ioEnable HTTPS for your GitHub pages websiteGo to your GitHub repository settings. Under Settings &amp;gt; GitHub Pages &amp;gt; Custom domain check the Enforce HTTPS checkbox.After a while (up to several hours) your domain should be available once with an SSL certificate. Go to https://yourdomain and check if you can see your website.NET::ERR_CERT_COMMON_NAME_INVALID errorIf after entering https: //yourdomain you see a browser warning and NET :: ERR_CERT_COMMON_NAME_INVALID error - make sure that you put www.yourdomain under Settings &amp;gt; GitHub Pages &amp;gt; Custom domain.  Adding the www prefix should fix the problem.Verify Domain in Google Search Console via DNSTo add your website to Google search, you must verify your domain on Google Search Console .      Select Domain property type:http://    Copy the TXT record you‚Äôll get:  Log into your domain`s admin panel.  Add a new DNS record and select TXT as a record type.  Fill  fields with the following information: name/host - empty, TTL - 86400 or default, answer/text -  your Google verification text from previous step.  Click Verify.Your domain can not be verified right away in Search Console. If you see a similar view to the picture below - this means that your website has not yet been confirmed.It may take a few minutes (up to 48 hours) to update your DNS. In my case, the domain was verified in 10 minutes. That`s all! There‚Äôs no guaranteed time-frame for how long it will take for your website to appear in Google‚Äôs search results. It can take anywhere from hours to weeks.Thanks for reading the post. See you later!",
      "url"      : "/blog/How-to-set-up-custom-domain-for-Github-Pages-with-HTTPS/",
      "image"    : "/images/github-custom-domain.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "Jekyll, CircleCI",
      "title"    : "Creating Jekyll Automated Deployment to GitHub Pages with CircleCI",
      "description": "A few days ago I logged in to Google Webmaster Tools to check if my blog is a...",
      "content": "A few days ago I logged in to Google Webmaster Tools to check if my blog is already available on google. I was surprised because the site was blocked. The addresses in sitemap.xml pointed to localhost: 4000/page-address. It‚Äôs all because I was building a blog locally and pushing a ready, built version from _sites directory to GitHub repository. I thought I would automate the deployment  process using one of the to Cl/CD - CircleCICircleCICircleCI provides very interesting (and free, which is important for me) service that allows you to utilize continuous integration in your development process.  CircleCI seamlessly integrates with GitHub, GitLab, BitBucket so you can automate your build, test, and deploy pipeline. There are many other Continuous Integration tools available on a market (Travis CI, Go CD, GitLab CI) however, I liked CircleCi the most. I encourage you to read the documentation.Requirements:  Github account  Repository with the Jekyll blog source code  Blog template based on JekyllAutomatically deploying Jekyll blog to GitHub PagesCurrently, I have one public repository to which I push the contents of the locally generated _site folder. I want to prepare:  A private repository with the entire Jekyll template code (I do not want to share my template code on the public repo)  A public repository to which CircleCI pipeline will push the generated _site contentIn my case, these two repositories are in different GitHub accounts. This is because I created a separate account for my blog. However, this does not matter when it comes to building automation.CircleCI ConfigurationFirst, log in to CircleCi  using the Github account. If you have two accounts like me (One for the blog, the second for yourself) - use the second one. This is where we will store the entire Jekyll template code in the private repository.After logging in you should see your repositories. Select the repository where you will store the entire template code.Now we have to define a deployment pipeline. CircleCI configuration is stored in a single YAML file located at .circleci/config.yml in the root of your project‚Äôs directory.Config.ymlDetailed instructions on how to create configuration can be found on the https://circleci.com/docs/2.0/writing-yaml/.My configuration is simple and contains only a few steps:defaults: &amp;amp;defaults    working_directory: ~/repo  version: 2  jobs:    build:      &amp;lt;&amp;lt;: *defaults    docker:        - image: circleci/ruby:2.6      environment:      steps:        - checkout        - run:            name: Bundler Install            command: gem install bundler        - run:            name: Rsync Install            command: sudo apt install rsync        - run:            name: Install Dependencies            command: bundle install        - run:            name: Jekyll build            command: bundle exec jekyll build        - deploy:            name: Deploy Blog to GitHub            command: |              if [ $CIRCLE_BRANCH == &#39;master&#39; ]; then                bash .circleci/deploy.sh              fi  workflows:    version: 2    build:      jobs:        - buildI used a CircleCI pre-built docker image that comes with tools that are useful to build Jekyll theme (Ruby and Rails image). In my pipeline, I install the bundler, which is needed to install all of the dependencies specified in the Gemfile file. I build a template just like locally - using bundle exec Jekyll build. You probably wonder why I added the  Rsync Install step.  This is to synchronize the newly generated theme with the currently used. In Linux, you can not move files with overwriting, that‚Äôs why I‚Äôm using Rsync.Deploy.sh script# Clone Jekyll generated template repository  git clone https://&amp;lt;GitHub Personal access token&amp;gt;@github.com/dev-diary/dev-diary.github.io.git  cd dev-diary.github.io    # Adding only files that have changed to the currently used template rsync -a ../_site/ .    #Setting GIT user  git config --global user.email &quot;michael.fabjanski@gmail.com&quot;  git config --global user.name &quot;Michal&quot;    # Preparation of backup branch name with (Branch from before new change)  BRANCH_NAME=backup-$(date -d &quot;today&quot; +&quot;%Y%m%d%H%M&quot;)  git checkout -b $BRANCH_NAME  git push -q https://7d2c83a2ddc30630bb41d19177775e30c09d29b1@github.com/dev-diary/dev-diary.github.io.git $BRANCH_NAME    #Add new changes to the generated template code and push it  git checkout master  git add .  git commit -m &quot;Builded new version - $(date -d &quot;today&quot; +&quot;%Y%m%d%H%M&quot;)&quot;  git push -q https://&amp;lt;GitHub Personal access token&amp;gt;@github.com/dev-diary/dev-diary.github.io.gitI clone the repository with the generated template. Then I only add new changes (generated by the pipeline in the _site folder). Because I use the second repository for the blog (it is not connected to CircleCi), I had to generate GitHub Personal access token.Before the commit, I create a branch with back up.In the end, I commit the changes and push to the repository with the generated theme.Let‚Äôs run our pipelineAfter adding my private repository with the entire template code in CircleCI - the tool automatically triggers builds after each commit.This is the sample build:After each commit to the master in my private repository, after about 30 seconds, a new commit is added to the public blog repository.You must use Bundler 2 or greater with this lockfile errorIf your build was a fail and you saw this message: warn_for_outdated_bundler_version&#39;: You must use Bundler 2 or greater with this lockfile - you have to add gem update --system step before installing bundler (See more on GitHub)Testing in CIIt is good practice to automatically test new functionalities before deployment. You can use HTML Proofer - set of tests to validate HTML. It is required to add a dependency to the Gemfile: gem  &#39;HTML-proofer&#39; and one more step to circle.yml:      - run:            name: Run Tests          command: bundle exec htmlproofer ./_site -check-htmlSummaryIt works! I have a private repository with the code of my template. I am the only one who has access to theme code. After each commit on the master branch - my template is automatically built and pushed to Github pages repository. Within a few seconds after pushing changes, the new version of the blog is available online.",
      "url"      : "/blog/Creating-Jekyll-Automated-Deployment-With-CircleCI/",
      "image"    : "/images/Automated-deployment-With-CircleCI.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "java, oop, interview",
      "title"    : "Object Oriented Design Principles Everythone Should Know",
      "description": "During my study, I have collected quite a large and interesting list of objec...",
      "content": "During my study, I have collected quite a large and interesting list of object-oriented programming  design principles that may be useful to you.  This post is a shortened note. I invite you to explore knowledge reading books such as ‚ÄúClean Architecture‚Äù, Martin Robert C.  Ready? I invite you to read the 10 most important OOP principles.Object-Oriented Design Principles represent a set of rules that are the essence of object-oriented programming and help us/others to prepare well, easy to understand design.SOLIDSolid is a set of five rules which tell us how to arrange our methods and data structures in classes. There are three main goals to understand and use SOLID: ‚úì Code and functionality changes are easier ‚úì Code is easy to understand ‚úì Software structures are the basis of components that can be used in many software systems There are five SOLID principles (each letter - one principle):Single Responsibility PrincipleSingle Responsibility Principle tells us that each software entity (classes, modules, methods) is designed to assume only one responsibility. If a code change is to be made, we should need to make a changes in one class that processes it. The good example is the Employee class from a company application:public class Employee {    private String firstName;    private String lastName;    private BigDecimal salaryInUSD;    private BigDecimal salaryInEuro;    public Double getSalaryInPLN() {        return salaryInUSD * Exchange.getDollarToZlotyRate();    }    public Double getSalaryInEuro() {        return salaryInEuro * Exchange.getDollarToEuroRate();    }Why Employee class have to know something about currency exchange?  By putting these two methods into a single Employee class, the developers have coupled Employee class with class responsible for exchange rates. How to do it to comply with the Single Responsibility Principle? We should remove getSalary.. methods from Employee class and create new class (e.g ExchangeService, SalaryCalculator, SalaryConverter‚Ä¶) which has knowledge of exchange rates. Next, we should provide a salary to ExchangeService class. ExchangeService takes the salary, calculate salary in another currency and return it.Open/closed principleOpen/closed principle tell us that sofware entities should be open for extension, but closed for modification. Developer‚Äôs goal is to extend a class/module functionality without modyfying its source code. Let‚Äôs imagine creating a Square class. In accordance with the Single Responsibility Principle, you create a Square class and AreaCalculator which contain the method calculateArea().See the following example:public class Rectangle {    private double length;}public class AreaCalculator {        public double calculateArea(Square shape) {        return shape.getLength() * shape.getLength();    }}Unfortunately, after some time we get a new task - we have to add two new figures: a triangle and a trapeze. The only solution is to modify the calculateArea() method:public class AreaCalculator {    public double calculateArea(Square shape) {        if (shape instanceof Square) {            return shape.getLength() * shape.getLength();        } else if (shape instanceof Triangle) {            return (shape.getLength() * shape.getHeight()) / 2;        } else if (shape instanceof Trapeze) {            return (...);        } else {            return new RuntimeException(&quot;Cannot calculate area for provided shape&quot;);        }    }}This code starts to look like Arrow Anti-Pattern How to do it in accordance with O/C principle? You should use Shape interface:public interface Shape {    double getArea();}And implementation:public class Suqare implements Shape {    private double length;    @Override    public double getArea() {        return (length * length);    }}Thanks to it AreaCalculator does not have to know all kinds of shapes. It relying on Shape abstraction:public class AreaCalculator {    public double calculateArea(Square shape) {       return shape.getArea();    }}We‚Äôve just made AreaCalculator closed for modification. If we get the task of creating a new shape - we will not have to modify this class. However, we can extend it.Liskov Substitution PrincipleLiskov Substitution Principle is a rule about the contract of the clasess: if a base class satisfies a contract, then by the LSP derived classes must also satisfy that contract. The main objectives of this principle are: ‚úì Classes in the application should be swapped by their subclasses without affecting the correctness of the program, i.e. the inheriting class must be a good equivalent of the base class. ‚úìA subclass should not do less than the base class. So it should always do more. Good example is the‚ÄúSquare extends Rectangle‚Äù class:public class Rectangle {    private int height;    private int width;    public void setHeight(int newHeight) {        this.height = newHeight;    }    public void setWidth(int newWidth) {        this.width = newWidth;    }    public int getWidth() {        return width;    }    public int getHeight() {        return height;    }}Mathematically, a square is a rectangle. Most people would misinterpret ‚Äúis a‚Äù relation and model the relationship between the rectangle and a square with inheritance:public class Square extends Rectangle {    @Override    public void setHeight(int height) {        super.setHeight(height);    }    @Override    public void setWidth(int width) {        super.setWidth(width);    }}As you probably guess, you can not have two different dimensions for a square. It is possible to bypass this by:public class Square extends Rectangle {    @Override    public void setHeight(int height) {        super.setHeight(height);        super.setWidth(height);     }    @Override    public void setWidth(int width) {        super.setWidth(width);         super.setHeight(width);    }}We overrided setHeight and setWidth methods to set both dimensions to the same value.  What do you think of this fix?This design breaks LSP. A client can works with instances of Rectangle, but breaks when instances of Square  are passed to it:double countArea(Rectangle rec) {    rec.setWidth(10);    rec.setHeight(5);//It will be a fail for the square:    assertThat(rec.area() == 50);}How to do it correctly? The most critical aspect to inheritance is that we should model inheritance based on behaviours, not object properties. The easiest way to understand this is by way of example:interface Shape {    public double area();}public class Square implements Shape {    private double size;    public void setSize(double size) {        this.size = size;    }    @Override    public double area() {        return size * size;    }}public class Rectangle implements Shape {    private double height;    private double width;    public void setWidth(double width) {        this.width = width;    }    public void setHeight(double height) {        this.height = height;    }    @Override    public double area() {        return height * width;    }}Now clients of Shape cannot make any behavior changes via setter methods. When clients have to change properties of shapes, they have to do it in concrete classes.Interface Segregation PrincipleThe main assumption of the ISP:  No client should be forced to depend on methods it does not use.in other words:  Many client-specific interfaces are better than one general purpose interface.So interfaces that we create should not contain methods that we do not need. The class that implements the interface can not be forced to implement methods that it does not need, and this is often the case with large interface.Let us understand the interface segregation principle by below example:public interface GenerateTimeSheet{  public void generateExcel();  public void generateCSV();}We have one interface with two methods to generate time sheet report (e.g for Employee). Consider a case client TimeSheet wants to use this interface but want to use only Excel time sheets. The interface forces client to implement an unnecessary method generateCSV();.A better solution would be breaking the GenerateTimeSheet interface into two small ones which contains separate methods.Dependency Inversion PrincipleThe general idea of this principle is as simple: High-level modules, which provide complex logic, should be easily reusable and unaffected by changes in low-level modules.Robert C. Martin‚Äôs definition of the Dependency Inversion Principle consists of two goals:  High-level modules should not depend on low-level modules. Both should depend on abstractions.  Abstractions should not depend on details. Details should depend on abstractions.In practice DIP tells that a method requires an interface object instead of specific class. This way we can pass many different versions of our entity into the same method.public class EventService {    private DBRepository repository = new DBRepository();    public void addEvent(Event event) {        repository.saveEvent(event);    }    public void removeEvent(String event) {        repository.deleteEvent(event);    }}EventService class uses concrete DBRepository class which save or delete events from the database. In above example EventService is High-level module.  DBRepository is a low-level module. We have a direct dependence between classes here. In this way, we violate the DIP policy. How to do it correctly? To solve the above problem, we should make the EventService class not dependent on the DBRepository class. In addition, both classes must depend on abstraction. Let‚Äôs create an abstraction - Repository interface. It will have methods for writing and reading tasks:  public interface Repository {      void saveEvent(Event Event);      void deleteEvent(Event event); } Let‚Äôs change the EventService class to use the Repository interface and thus depend on abstraction: public class EventService {    private Repository repository;    public EventService(Repository repository) {        this.repository = repository;    }    public void addEvent(Event event) {        repository.saveEvent(event);    }    public void removeEvent(String event) {        repository.deleteEvent(event);    }} Now we have to implement our DBRepository class (it will also depend on abstraction):public class DBRepository implements Repository {    @Override    public void saveEvent(Event event) {    }    @Override    public void deleteEvent(Event event) {    }} Relationships have been inverted. Now the ‚Äúhigh level module‚Äù does not depend on the ‚Äúlow level module‚Äù. The lower layer module depends on the abstract interface from the upper layer (Repository interface). Changes in the module at the lower level do not affect the module at a higher level.If, for example, we need to save events in the file instead of in a database it is simple. It is enough to add the appropriate class at a lower level (FileRepository).DRY - Don‚Äôt Repeat YourselfWe should write a code that is reusable, not repeat the logic contained in one place in the application. If you are close to the copy/paste code, think about creating an abstraction (loop, common interface, function, class, some design pattern, eg Strategy, etc.) that you will be able to repeatedly use.KISS - Keep it simple, stupid!Simplicity (and avoiding complexity) should be a priority during programming. The code should be easy to read and understand, requiring as little effort as possible.Each method should only solve one small problem, not many use cases. If you have a lot of conditions in the method, break these out into smaller methods.This is not only about the way the code is created and written, but also about the names of our classes, methods, variables and objects. Everything should be written in such a way that the name of the variable, object, method or class tells what its purpose or use is.YAGNI - You Aint‚Äôt gona need itThis is a nice principle that says that in our program we should put the most important functionalities that we will need at a given moment. We should not write code that will not be useful at the moment, which will be redundant and which will only grow unnecessarily in our program.ADP - Acyclic dependencies principleThis principle says that there should be no cycles in the dependency structure.An exemplary structure breaking this principle will be when: packet A has a dependency in packet B, which has a relationship in packet C, which in turn has a relationship in packet A:We can prevent this by using the Dependency inversion principle, design patterns (eg Observer) or create a new package and put all the common dependencies there.LoD - Law of DemeterThe Law of Demeter is often described this way:  ‚ÄúOnly talk to your immediate friends.‚ÄùThis principle says that a class‚Äôs method can only refer to:  methods of the same class  fields (and their methods) of the same class  parameters (and their methods) passed to this method  objects (and their methods) that this method will createAdvantages:  reduction of dependence  the code calling the given method does not have to know the structure of other objects  changes in other objects do not require changing the method",
      "url"      : "/blog/10-Object-oriented-design-principles-everythone-should-know/",
      "image"    : "/images/Object-Oriented-Design-Principles.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "java, non-blocking",
      "title"    : "java.nio - How to build a simple non-blocking server in Java?",
      "description": "Building non-blocking server in JavaSome time ago (after Spring 5 release wit...",
      "content": "Building non-blocking server in JavaSome time ago (after Spring 5 release with WebFlux) I started getting interested in non-blocking http servers (Java reactive frameworks are based on this). That‚Äôs why I decided to write a post in which I will show how to create a non-blocking server and a client. We will send messages from the client to the server and display them.Let‚Äôs start!What is non-blocking server?In the traditional approach, the server listens in the loop for any traffic on a given port. As soon as a new request appears, it delegates the request to previously created thread pool. This approach has some disadvantages. Firstly, the number of concurrently served clients have to be at most equal to the size of the thread pool. Moreover, if any client has weak internet connection - then the thread assigned to his request wastes most of the time waiting for more bits.In non-blocking approach - one thread can handle multiple queries at a time. How? Thanks to the non-blocking IO implemented in java.nio.package.java.nioJava New IO (nio) was created in JDK 1.4 to allow all  programmers to implement very fast input/output without having to deal with custom native code.It was built based on three main functionalities: buffers, channels and selectors.BuforBufor is a block of memory used to temporarily store data while it is being moved from one place to another.ChannelChannel represents a connection to an objects that are capable of performing I/O operations, such as files and sockets. It uses buffers from which it reads the data to send and writes received information.SelectorSelector is one of Java NIO class. The priciple of selector is very simple. After creation, we have to register in selector all the channels that we want to listen to. As a result of this operation, each channel is assigned with selectionKey. SelectionKey is an object that identyfying channel and contains information about channel‚Äô status (e.g readiness to accept request). Each key holds information about who is making the request and what type of the request is.This is, each instance of Selector can monitor more socket channels and thus more connections. When something happens on the channel, the selector informs the application to process the request.Create NIO ServerLet‚Äôs code! We will create our non-blocking server and client. Server will accept connections on port 8089 on localhost. We set it by using ServerSocket‚Äôs bind() method. To make the server non-blocking we will set ServerSocketchannel‚Äôs configureBlocking() method to false. Take a look at the following implementation:public class NonBlockingServer {    private static Selector selector = null;    public static void main(String[] args) {        try {            selector = Selector.open();//            We have to set connection host, port and non-blocking mode            ServerSocketChannel socket = ServerSocketChannel.open();            ServerSocket serverSocket = socket.socket();            serverSocket.bind(new InetSocketAddress(&quot;localhost&quot;, 8089));            socket.configureBlocking(false);            int ops = socket.validOps();            socket.register(selector, ops, null);            while (true) {                selector.select();                Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();                Iterator&amp;lt;SelectionKey&amp;gt; i = selectedKeys.iterator();                while (i.hasNext()) {                    SelectionKey key = i.next();                    if (key.isAcceptable()) {//                        New client has been accepted                        handleAccept(socket, key);                    } else if (key.isReadable()) {//                        We can run non-blocking operation READ on our client                        handleRead(key);                    }                    i.remove();                }            }        } catch (IOException e) {            e.printStackTrace();        }    }    private static void handleAccept(ServerSocketChannel mySocket,                                     SelectionKey key) throws IOException {        System.out.println(&quot;Connection Accepted...&quot;);        // Accept the connection and set non-blocking mode        SocketChannel client = mySocket.accept();        client.configureBlocking(false);        // Register that client is reading this channel        client.register(selector, SelectionKey.OP_READ);    }    private static void handleRead(SelectionKey key)            throws IOException {        System.out.println(&quot;Reading...&quot;);        // create a ServerSocketChannel to read the request        SocketChannel client = (SocketChannel) key.channel();        // Create buffer to read data        ByteBuffer buffer = ByteBuffer.allocate(1024);        client.read(buffer);//        Parse data from buffer to String        String data = new String(buffer.array()).trim();        if (data.length() &amp;gt; 0) {            System.out.println(&quot;Received message: &quot; + data);            if (data.equalsIgnoreCase(&quot;exit&quot;)) {                client.close();                System.out.println(&quot;Connection closed...&quot;);            }        }    }} You certainly noticed two important methods in the main loop of our server:isAcceptable() - checking if client is requesting a connection and isReadable() - method to read data when client has prepared data. IsReadable()will read data from the channel and put it into buffer. Next, we will send data from buffer onto the screen.Create ClientOur client is simple. We also use SocketChannel to connect to the channel and send messages in the buffer. At the end we close SocketChannel.  public class ServerClient {        public static void main(String[] args) {          try {              String[] messages = {&quot;I like non-blocking servers&quot;, &quot;Hello non-blocking world!&quot;, &quot;One more message..&quot;, &quot;exit&quot;};              System.out.println(&quot;Starting client...&quot;);              SocketChannel client = SocketChannel.open(new InetSocketAddress(&quot;localhost&quot;, 8089));                for (String msg : messages) {                  System.out.println(&quot;Prepared message: &quot; + msg);                  ByteBuffer buffer = ByteBuffer.allocate(1024);                  buffer.put(msg.getBytes());                  buffer.flip();                  int bytesWritten = client.write(buffer);                  System.out.println(String.format(&quot;Sending Message: %s\nbufforBytes: %d&quot;, msg, bytesWritten));              }                client.close();              System.out.println(&quot;Client connection closed&quot;);            } catch (IOException e) {              e.printStackTrace();          }      }  }   Connecting client to our serverWe have a client and a server ready. Let‚Äôs run it! I wll start with the server (it must be ready when the client sends a message).  Below you can see the result of client&amp;lt;-&amp;gt;server communication.Client:    Starting client...    Prepared message: I like non-blocking servers    Sending Message: I like non-blocking servers    bufforBytes: 27    Prepared message: Hello non-blocking world!    Sending Message: Hello non-blocking world!    bufforBytes: 25    Prepared message: One more message..    Sending Message: One more message..    bufforBytes: 18    Prepared message: exit    Sending Message: exit    bufforBytes: 4    Client connection closed    Server:    Connection Accepted...    Reading...    Received message: I like non-blocking servers    Reading...    Received message: Hello non-blocking world!    Reading...    Received message: One more message..    Reading...    Received message: exit    Connection closed...     SummaryI hope you liked this post. The server and client code is available on github: REPO URL.See you next time!",
      "url"      : "/blog/java.nio-How-To-Build-a-non-blocking-server-in-java/",
      "image"    : "/images/java_nonblocking_server.jpg",
      "author"   : "Michal Fabjanski"
    }
    ,
  
    {
      "category" : "openhift, kubernetes",
      "title"    : "Remote JMX Connection to Openhift (or Kubernetes) pod",
      "description": "Remote Debugging Applications on Openshift podsIn this post I would like to s...",
      "content": "Remote Debugging Applications on Openshift podsIn this post I would like to share my last challenge at work - remote debugging of an application running on Openhift. This method is also valid for Kubernetes pods.Set up JMXThe first thing you have to do is to enable and configure JMX flags. Start your program with following parameters:-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=3000-Dcom.sun.management.jmxremote.rmi.port=3001-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=127.0.0.1JMX use RMI for the communication between the JMX client and the remote JVM. That‚Äôs why I‚Äôve set two ports. JMX client will connect to hostname - 127.0.0.1:3001. You probably wonder how it can work if there is no RMI server running on localhost. This is because the next step is to set up Openshift/Kubernetes port forwarding.Port forwardingThanks to port forwarding feature you can forward one or more local ports to a pod.  You need to be locally logged on the Openhift. If you do not have it yet - I recommend downloading OpenShift Client Tools (Windows, Linux)Use following command to start the proxy and forward ports to the remote pod:oc login #login to Openshiftoc project #switch to your projectoc port-forward &amp;lt;POD-NAME&amp;gt; 8080 3000 3001Remember to replace  with the name of your pod. After that you shuld see output:oc port-forward my-app-46ztp 8080 3000 3001Forwarding from 127.0.0.1:8080 -&amp;gt; 8080Forwarding from 127.0.0.1:3000 -&amp;gt; 3000Forwarding from 127.0.0.1:3001 -&amp;gt; 3001JVisualVM connectionIf you have started proxy on the machine where you run JVisualVM, you can connect locally to RMI port: visualvm --openjmx localhost:3000",
      "url"      : "/blog/Remote-JMX-Connetion-to-Openhift-Pod/",
      "image"    : "/images/openshift-jmx.jpg",
      "author"   : "Michal Fabjanski"
    }
    
  
]
